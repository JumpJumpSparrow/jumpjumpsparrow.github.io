<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CF Blog</title>
    <description>iOS 开发，会 1.5 点web前端，Java web入门开发者</description>
    <link>http://junziboxue.com/</link>
    <atom:link href="http://junziboxue.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 14 May 2021 17:01:18 +0800</pubDate>
    <lastBuildDate>Fri, 14 May 2021 17:01:18 +0800</lastBuildDate>
    <generator>Jekyll v4.1.1</generator>
    
      <item>
        <title>WebRTC 信令交换与群聊实现</title>
        <description>&lt;p&gt;&lt;img src=&quot;../assets/images/webRTC/WebRTC_Logo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1什么是-webrtc&quot;&gt;1.什么是 WebRTC&lt;/h2&gt;

&lt;p&gt;WebRTC，全称：(Web Real-Time Communication),是一个免费的开源工程。 &lt;br /&gt;
Google 把 WebRTC 视为和 HTTP 一样，不仅仅是一种解决方案，而是一种标准。&lt;br /&gt;
使各种终端，包括 浏览器、原生应用等具备音视频通讯和即时通讯的能力。&lt;/p&gt;

&lt;h3 id=&quot;11-webrtc术语&quot;&gt;1.1 webrtc术语&lt;/h3&gt;

&lt;p&gt;Signaling channel(信令通道)&lt;/p&gt;

&lt;p&gt;一种资源，使应用程序可以通过交换信令消息来发现，建立，控制和终止对等连接。信令消息是两个应用程序相互交换以建立对等连接的元数据。该元数据包括本地媒体信息，例如媒体编解码器和编解码器参数，以及两个应用程序可能相互连接以进行实时流传输的可能的网络候选路径。
PS：信令通道通常由信令服务器提供（或信令服务）&lt;/p&gt;

&lt;h4 id=&quot;peer对等节点&quot;&gt;Peer（对等节点）&lt;/h4&gt;

&lt;p&gt;接入同一webrtc房间（逻辑划分的管理单元）的进行实时双向流传输的任何设备或应用程序&lt;/p&gt;

&lt;h4 id=&quot;session-traversal-utilities-for-nat-stun&quot;&gt;Session Traversal Utilities for NAT (STUN)&lt;/h4&gt;

&lt;p&gt;一种协议，用于发现您的公共地址(公网IP)并确定路由器中可能阻止与对等方直接连接的任何限制条件。
PS：Stun服务由STUN服务器提供&lt;/p&gt;

&lt;h4 id=&quot;traversal-using-relays-around-nat-turn&quot;&gt;Traversal Using Relays around NAT (TURN)&lt;/h4&gt;

&lt;p&gt;通过打开与TURN服务器的连接并通过该服务器中继所有信息来绕过对称NAT限制的服务器。
PS：当P2P链接建立失败，仍需要保证功能可用，这里就需要TURN服务器对所有数据进行中继。建立relay模式的链接
PS: TURN服务由TURN服务器提供&lt;/p&gt;

&lt;h4 id=&quot;session-description-protocol-sdp&quot;&gt;Session Description Protocol (SDP)&lt;/h4&gt;

&lt;p&gt;一种描述连接的多媒体内容的标准，例如分辨率，格式，编解码器，加密等，以便一旦数据传输，两个对等方就可以相互理解。
PS:描述终端信息的规范。&lt;/p&gt;

&lt;h4 id=&quot;sdp-offer&quot;&gt;SDP Offer&lt;/h4&gt;

&lt;p&gt;发起建立会话链接的SDP消息(主动发送方)，生成会话描述以创建或修改会话。它描述了所需媒体通信的各个方面。
PS：比如想要和一个对等节点建立链接。首先就得告诉对端，自身终端信息（分辨率，格式，编解码器，加密），而为了描述自身终端信息产生SDP 就被称为SDP offer&lt;/p&gt;

&lt;h4 id=&quot;sdp-answer&quot;&gt;SDP Answer&lt;/h4&gt;

&lt;p&gt;answer SDP由响应者响应邀约者发送的offer SDP。Answer主要包含终端协商结果(answer端终端信息)。例如，如果offer中的所有音频和视频流都被接受。&lt;/p&gt;

&lt;h4 id=&quot;interactive-connectivity-establishment-ice&quot;&gt;Interactive Connectivity Establishment (ICE)&lt;/h4&gt;

&lt;p&gt;一个允许您的Web浏览器(webrtc终端)与对等方连接的框架。&lt;/p&gt;

&lt;p&gt;ICE Candidate(Candidate)
一种能与对等方用来通信的一种方法(方式)。&lt;/p&gt;

&lt;h3 id=&quot;12-stun-turn-ice如何工作&quot;&gt;1.2 STUN TURN ICE如何工作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ClientA首先创建PeerConnection对象，然后打开本地音视频设备，将音视频数据封装成MediaStream添加到PeerConnection中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ClientA调用PeerConnection的CreateOffer方法创建一个用于offer的SDP对象，SDP对象中保存当前音视频的相关参数。ClientA通过PeerConnection的SetLocalDescription方法将该SDP对象保存起来，并通过Signal服务器发送给ClientB。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ClientB接收到ClientA发送过的offer SDP对象，通过PeerConnection的SetRemoteDescription方法将其保存起来，并调用PeerConnection的CreateAnswer方法创建一个应答的SDP对象，通过PeerConnection的SetLocalDescription的方法保存该应答SDP对象并将它通过Signal服务器发送给ClientA。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ClientA接收到ClientB发送过来的应答SDP对象，将其通过PeerConnection的SetRemoteDescription方法保存起来。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在SDP信息的offer/answer流程中，ClientA和ClientB已经根据SDP信息创建好相应的音频Channel和视频Channel并开启Candidate数据的收集，Candidate数据可以简单地理解成Client端的IP地址信息（本地IP地址、公网IP地址、Relay服务端分配的地址）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当ClientA收集到Candidate信息后，PeerConnection会通过OnIceCandidate接口给ClientA发送通知，ClientA将收到的Candidate信息通过Signal服务器发送给ClientB，ClientB通过PeerConnection的AddIceCandidate方法保存起来。同样的操作ClientB对ClientA再来一次。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样ClientA和ClientB就已经建立了音视频传输的P2P通道，ClientB接收到ClientA传送过来的音视频流，会通过PeerConnection的OnAddStream回调接口返回一个标识ClientA端音视频流的MediaStream对象，在ClientB端渲染出来即可。同样操作也适应ClientB到ClientA的音视频流的传输。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/webRTC/8fdbd5edc57ac9b4df227b875e1c0324.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2安装接入&quot;&gt;2.安装接入&lt;/h2&gt;

&lt;p&gt;拿iOS来说，使用 webRTC 需要以下步骤：&lt;/p&gt;

&lt;h4 id=&quot;21-接入-webrtc-sdk&quot;&gt;2.1 接入 webRTC SDK&lt;/h4&gt;
&lt;p&gt;通过pods安装 webRTC sdk, 注意使用的是谷歌官方的 ‘GoogleWebRTC’ SDK&lt;br /&gt;
最新版本的 GoogleWebRTC SDK 需要 iOS 10.0以上，&lt;br /&gt;
因此工程需要设置为： iOS Deplopment Target 10.0&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;pod 'GoogleWebRTC'
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;22-工程设置&quot;&gt;2.2 工程设置&lt;/h4&gt;
&lt;p&gt;因为需要访问相机、麦克风等音视频设备，需要在工程中添加配置&lt;/p&gt;

&lt;p&gt;info.plist 文件中添加&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//访问相机
&amp;lt;key&amp;gt;NSCameraUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;访问相机和拍照功能&amp;lt;/string&amp;gt;
//访问麦克风
&amp;lt;key&amp;gt;NSMicrophoneUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;打开麦克风发送语音&amp;lt;/string&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果想在应用进入后台时，继续保持通话，还需要添加&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;音视频通话要额外添加
&amp;lt;key&amp;gt;UIBackgroundModes&amp;lt;/key&amp;gt;
	&amp;lt;array&amp;gt;
		&amp;lt;string&amp;gt;voip&amp;lt;/string&amp;gt;
	&amp;lt;/array&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个版本的 SDK 并不支持 bitcode,因此还需要关闭 bitCode,&lt;br /&gt;
在这里是以开发SDK的形式接入webRTC,因此需要以下设置&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Pods -&amp;gt; TARGETS -&amp;gt; XXX -&amp;gt; BuildSettings -&amp;gt; Build Options -&amp;gt; Enable Bitcode -&amp;gt;NO  
Pods -&amp;gt; TARGETS -&amp;gt; GoogleWebRTC -&amp;gt; BuildSettings -&amp;gt; Build Options -&amp;gt; Enable Bitcode -&amp;gt;NO
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为 视频通话使用 RTCMTLVideoView 渲染视频，其内部使用 Metal 图形接口来渲染图像，&lt;br /&gt;
该接口不支持ArmV7,因此需要在 valid Architecture 选项中 移除 arm v7指令集&lt;/p&gt;

&lt;h2 id=&quot;3-架构设计&quot;&gt;3. 架构设计&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Factory 类：全局持有一个 RTCPeerConnectionFactory 类实例，管理本地 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCVideoTrack&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCAudioTrack&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCVideoSource&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCAudioSource&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCCameraVideoCapturer&lt;/code&gt;等类的实例，以上类的实例都是全局唯一的。&lt;/li&gt;
  &lt;li&gt;Device 类: 控制本地 摄像头的开/关，前后摄像头的切换，音频输出 扬声器和听筒的切换。&lt;/li&gt;
  &lt;li&gt;RTCManager类: 负责管理所有 peer connection，包括生成、关闭、断线重连等功能&lt;/li&gt;
  &lt;li&gt;RTCClient 类：由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCManager &lt;/code&gt;管理，负责 一个 Peer connection 的所有事务，包括webrtc的事件回调、生成/接收SDP和ICE信息.&lt;/li&gt;
  &lt;li&gt;RoomManager 类: 负责信令层的事务，管理通话事件.&lt;/li&gt;
  &lt;li&gt;AVChatManager 类: 对外暴露的接口类。外部统一由此类访问 音视频通话功能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意事项：webRTC 生成的很多对象需要由外部持有，否则生成后会自动释放。如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCVideoSource&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCVideoTrack&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;事件集合：&lt;/p&gt;

&lt;h2 id=&quot;4群聊建立流程&quot;&gt;4.群聊建立流程&lt;/h2&gt;

&lt;p&gt;因为 WebRTC 是 P2P 连接，如果需要多人同时通信的话，就需要建立复杂的连接关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/webRTC/p2p_connection.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图，如果3个人通话，就需要建立 3条 P2P 连接，而4个人通话就需要 6 条P2P连接，5个人通话就需要 10条P2P连接。 &lt;br /&gt;
如果是 N 个人通话（N &amp;gt;= 3),就需要 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N(N-3)/2 + N&lt;/code&gt; 条连接。人数越多，需要建立的连接会呈O(n^2)的趋势增长。&lt;br /&gt;
因此，P2P方案并不适合多人通讯，考虑到 终端 带宽和计算能力，要想保持高质量的音视频通话，人数上限大概在 6 个左右(参考微信)。 &lt;br /&gt;
超过6人 P2S 方案更适合。如果仅是音频通话的情况，那么 P2P 通话人数可以增加一个数量级（估计）。&lt;/p&gt;

&lt;p&gt;接下来说一下，如何建立起 多人通话的流程,此处已 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A B C D&lt;/code&gt; 4人通话为例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/webRTC/p2p_topology.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;41-p2p连接流程&quot;&gt;4.1 P2P连接流程&lt;/h4&gt;

&lt;p&gt;假设 A 与 B建立连接. A 发起邀请等待 B 回复:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;B 接受后, Server 发送Accept信令给A&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A 接收到 ACCEPT信令后, 创建 PeerConnecton, 生成 OFFER, 返回给B,&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B接到OFFER后,创建与之对应的PeerConnecton,设置OFFER, 然后生成 ANSWER 返回给A.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SDP 信息交换完毕后,交换ICE信息,连接完成.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;42-多端-p2p-连接建立流程&quot;&gt;4.2 多端 P2P 连接建立流程&lt;/h4&gt;

&lt;p&gt;假设 有 A B C D 四个客户端&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A 向 B C D 发起邀请。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假设 B C D 依次接受邀请，（无论是何种顺序，还是同时接受，这里都要串行处理）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B 接受，同时给 A 发送 ACCEPT 信令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A 接到 B 发来的 ACCEPT 信令，A 发送 OFFER SDP 信息给B,
 B 返回 ANSWER SDP 给A, A　B交换ICE信息,A B 连接完毕.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;C 接受,  同时给 A B 发送 ACCEPT 信令,A B 发送 OFFER SDP 信息给C,
 C 返回 ANSWER SDP 给A B, AC BC交换ICE信息,A B C 连接完毕.&lt;/li&gt;
  &lt;li&gt;D 接受, 同时给 A B C发送 ACCEPT 信令,A B C发送 OFFER SDP 信息给D,
 D 返回 ANSWER SDP 给A B C, AD  BD CD交换ICE信息,A B C D 连接完毕.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一次连接 对于邀请者来说,就算是发送一次 OFFER 和接到一次 ANSWER,对于被邀请者来说,就是接到 一次OFFER 和发送一次ANSWER.
一个PeerConnection 只能建立一次连接 不能建立两次连接（例如 不能重复的发送和接收同一个客户端的OFFER&lt;/p&gt;

&lt;h2 id=&quot;5-断线重连-机制&quot;&gt;5 断线重连 机制&lt;/h2&gt;
&lt;p&gt;假设 A B连接失败,A为主动发起对话的那方,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;主动发起邀请的那方,销毁原先的 PeerConnection,&lt;/li&gt;
  &lt;li&gt;重新创建与B相对应的 Peer Connection,然后发送 OFFER SDP给 B,&lt;/li&gt;
  &lt;li&gt;B 收到 OFFER SDP 后,将B本地与A相对应的PeerConnection 销毁,&lt;/li&gt;
  &lt;li&gt;创建新的Peer Connection 与A对应,设置 OFFER SDP 后,&lt;/li&gt;
  &lt;li&gt;生成 ANSWER 返回给A，交换ICE　重新连接．&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-连接状态展示&quot;&gt;6. 连接状态展示&lt;/h2&gt;

&lt;p&gt;PC 间连接状态变化,通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onconnectionstatechange&lt;/code&gt;接口回调获得.
共6种状态,分别是:&lt;/p&gt;

&lt;p&gt;“new”&lt;br /&gt;
“connecting”&lt;br /&gt;
“connected”&lt;br /&gt;
“disconnected”&lt;br /&gt;
“failed”&lt;br /&gt;
“closed”&lt;/p&gt;

&lt;p&gt;连接状态变化后,给出相应的提示文案.&lt;/p&gt;

&lt;h2 id=&quot;7多媒体控制&quot;&gt;7.多媒体控制&lt;/h2&gt;
&lt;p&gt;多媒体控制&lt;br /&gt;
1.镜头反转&lt;br /&gt;
2.静音/关闭摄像头&lt;br /&gt;
3.扬声器选择(听筒/外放)&lt;br /&gt;
4.画面分辨率选择(一般,清晰,高清)&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://webrtc.github.io/samples/&quot;&gt;官方示例&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.cocoapods.org/pods/GoogleWebRTC&quot;&gt;Pods 安装&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://webrtc.org/?hl=en&quot;&gt;WebRTC 官网&lt;/a&gt;
&lt;a href=&quot;https://webrtc.org.cn/20190517_tutorial4_webrtc_ios/&quot;&gt;WebRTC 入门教程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/WebRTC.git&quot;&gt;WebRTC入门教程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/m0_37263637/article/details/103999418&quot;&gt;WebRTC 连接建立&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.aws.amazon.com/zh_cn/kinesisvideostreams-webrtc-dg/latest/devguide/kvswebrtc-how-it-works.html&quot;&gt;webRET 工作方式&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Jan 2021 18:30:00 +0800</pubDate>
        <link>http://junziboxue.com/webrtc-ios</link>
        <guid isPermaLink="true">http://junziboxue.com/webrtc-ios</guid>
        
        <category>WebRTC</category>
        
        
      </item>
    
      <item>
        <title>从里到外，聊一聊 FLutter</title>
        <description>&lt;h3 id=&quot;1-什么是flutter&quot;&gt;1. 什么是flutter&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/new-to-flutter/whatIsFlutter.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Flutter 是 Google 开源的 UI 工具包，帮助开发者通过一套代码库,&lt;br /&gt;
高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。&lt;/p&gt;

&lt;h4 id=&quot;11-flutter-优势&quot;&gt;1.1 flutter 优势&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Flutter 很好的解决了跨端一致性问题，一套代码无差异的同时跑在 iOS 与 Android 两端；&lt;/li&gt;
  &lt;li&gt;开发体验基本接近前端.&lt;/li&gt;
  &lt;li&gt;支持 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on device&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hot Reload&lt;/code&gt; ，&lt;/li&gt;
  &lt;li&gt;Flutter 在 Android Studio 中通过插件实现实时预览并支持交互的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hot UI&lt;/code&gt; 能力，以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; Layout Explorer&lt;/code&gt; 可视化布局，让Flutter 的开发效率和前端效率基本持平。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/374113031/answer/1252582543&quot;&gt;阿里巴巴淘系技术&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-flutter-架构&quot;&gt;2. FLutter 架构&lt;/h3&gt;

&lt;p&gt;Flutter的整体架构共分为三层，从下到上分别为：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Embedder层&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine层&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Framework层&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/new-to-flutter/arch-diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分别对应：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Framework层：用Dart实现的上层UI SDK。&lt;/li&gt;
  &lt;li&gt;Engine层：渲染引擎层。&lt;/li&gt;
  &lt;li&gt;Embedder层：操作系统底层适配层。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Framework&lt;/code&gt; 层：Dart实现的上层UI SDK
实现了：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animation（动画&lt;/code&gt;）、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Painting（图形绘制）&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gestures（手势操作）&lt;/code&gt;等功能，并包装成对应的 api 提供给上层开发者调用。为了保证Flutter所绘制的控件与原生控件风格类似，Flutter封装了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Material&lt;/code&gt;（对应Android）、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cupertino&lt;/code&gt;（对应iOS）风格的UI组件库，供开发者直接使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt; 层：Skia渲染 + DartVM 引擎 &lt;br /&gt;
  这层主要包含三块：Skia、Dart、Text。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Skia 是渲染引擎，为 Framework 层提供“底层渲染”能力。&lt;/li&gt;
      &lt;li&gt;Dart 是 Dart 运行时引擎，为 Framework 层提供运行时调用Dart和渲染能力。&lt;/li&gt;
      &lt;li&gt;Text 是文字排版，为 Framework 层提供视图排版能力。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Embedder&lt;/code&gt; 层：操作系统适配&lt;br /&gt;
对不同平台操作系统的适配，包括一些配置：surface、线程、插件等特性。
由于Flutter相关特性并不多，因此对不同平台操作系统的适配成本很低。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3执行流程&quot;&gt;3.执行流程&lt;/h3&gt;

&lt;p&gt;从结构上看，Flutter渲染由UI Thread与GPU Thread相互配合完成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/new-to-flutter/architect.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1）UI Thread&lt;/p&gt;

&lt;p&gt;对应图中1-5，执行Dart VM中的Dart代码（包含应用程序和Flutter框架代码），主要负责Widget Tree、Element Tree、RenderObject Tree的构建，布局、以及绘制生成绘制指令，生成Layer Tree（保存绘制指令）等工作。&lt;/p&gt;

&lt;p&gt;2）GPU Thread&lt;/p&gt;

&lt;p&gt;对应图中6-7，执行Flutter引擎中图形相关代码（Skia），这个线程通过与GPU通信，获取Layer Tree并执行栅格化以及合成上屏等操作，将Layer Tree显示在屏幕上。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;注：图层树（Layer Tree）是Flutter组织绘制指令的方式， 
类似于Android Rendering里的View DisplayList，都是组织绘制指令的一种方式。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;UI Thread与GPU Thread属于生产者和消费者的角色。&lt;/p&gt;

&lt;h3 id=&quot;flutter-渲染工作流水线&quot;&gt;Flutter 渲染工作流水线&lt;/h3&gt;

&lt;p&gt;渲染原理解释了 flutter 是如何跨平台的
&lt;img src=&quot;../assets/images/new-to-flutter/rendering-pipline.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;渲染过程，UI线程完成布局、绘制操作，生成Layer Tree；
GPU线程执行合成并光栅化后交给GPU来处理，其中几个关键步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Animate: 遍历_transientCallbacks，执行动画回调方法；&lt;/li&gt;
  &lt;li&gt;Build: 对于dirty的元素会执行build构造，没有dirty元素则不会执行，对应于buildScope()&lt;/li&gt;
  &lt;li&gt;Layout: 计算渲染对象的大小和位置，对应于flushLayout()，这个过程可能会嵌套再调用build操作；&lt;/li&gt;
  &lt;li&gt;Compositing bits: 更新具有脏合成位的任何渲染对象， 对应于flushCompositingBits()；&lt;/li&gt;
  &lt;li&gt;Paint: 将绘制命令记录到Layer， 对应于flushPaint()；&lt;/li&gt;
  &lt;li&gt;Compositing: 将Compositing bits发送给GPU， 对应于compositeFrame()；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GPU线程通过skia向GPU硬件绘制一帧的数据，GPU将帧信息保存到FrameBuffer里面，
然后视频控制器会根据VSync信号，从FrameBuffer取帧数据传递给显示器，从而显示出最终的画面。（Vulkan,OpenGL,Metal）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/new-to-flutter/render-flow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4渲染策略&quot;&gt;4.渲染策略&lt;/h3&gt;

&lt;p&gt;在Flutter中，Everything is widget。所有 Widget 会组成 Widget Tree 。&lt;br /&gt;
界面更新时，会更新 Widget Tree ，再更新 Element Tree ，最后更新 RenderObjectTree 。&lt;/p&gt;

&lt;p&gt;分为4个阶段，分别是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;布局阶段 =&amp;gt; 绘制阶段 =&amp;gt; 合成阶段 =&amp;gt; 渲染阶段  
（Layout =&amp;gt; Paint =&amp;gt; Composite =&amp;gt; Rasterize）
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/new-to-flutter/layout-tree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;布局（Layout）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Flutter采用 “深度优先” 机制遍历Widget Tree。
 为了防止孩子节点的变化，导致整个 Widget Tree 重新布局。
 Flutter加入了 “布局边界” 机制（Relayout Boundary）
 布局完成后，树上每个节点都确定了“尺寸大小”和“位置”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;绘制（Paint）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;布局完成后，确定了树上的控件的“尺寸”与“位置”。
接下来是绘制阶段。&lt;/p&gt;

&lt;p&gt;和布局类似，Flutter也是采用 “深度优先” 机制遍历渲染树。
先绘制自身，再绘制子节点。
为了解决绘制覆盖问题，Flutter采用了也是和布局阶段相似的策略： 重绘边界 机制（Repaint Boundary）。
其实，本质上就是加个新的图层，避免在同一图层重绘产生影响。
典型的例子是，ScrollView。
一旦设置好重绘边界，滚动时，只会重绘ScollView中的视图内容，而其他部分不用重新绘制。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;合成（Composite）
 由于绘制出来的渲染树，会有很多层，同步多层渲染会出现性能问题。&lt;br /&gt;
 因此，Flutter会在渲染前，将多个渲染树图层进行合成。&lt;br /&gt;
 根据多层渲染树的大小、层级、透明度等计算后， &lt;br /&gt;
 合成为最终“简化版”的渲染树，以提高下一步的渲染效率。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;渲染（Rasterize）
 将处理过的“简化版”渲染树，交给Skia引擎转换成“二维图像数据”。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后 Skia 把计算好的图形数据，通过 OpenGL 接口交给 GPU 渲染，走 GPU 工作流水线：
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;顶点着色器 =&amp;gt; 形状装配 =&amp;gt; 几何着色器 =&amp;gt; 光栅化 =&amp;gt; 片段着色器 =&amp;gt; 测试与混合&lt;/code&gt;。&lt;br /&gt;
 然后，GPU工作流水线六阶段完成。最终，展示到终端屏幕上。&lt;br /&gt;
 当然这只是一个垂直同步信号（VSync）的过程。（按60fps算，一秒需要60个VSync才不会感到卡顿。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/new-to-flutter/full-pip-line.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5工程实例讲解&quot;&gt;5.工程实例讲解&lt;/h3&gt;

&lt;h5 id=&quot;51常用组件&quot;&gt;5.1.常用组件&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;../assets/images/new-to-flutter/widget-tree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5 id=&quot;52特性展示&quot;&gt;5.2特性展示&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;4.1 hotReload&lt;/li&gt;
  &lt;li&gt;4.2 Android/iOS style&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考资料&lt;br /&gt;
&lt;a href=&quot;https://flutter.github.io/samples/#&quot;&gt;Flutter Samples&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/183770848?utm_source=wechat_session&quot;&gt;了解Flutter渲染机制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/8b0572f2c23a&quot;&gt;iOS 浅谈GPU及“App渲染流程”&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.im/post/6844904122257276936&quot;&gt;Flutter 究竟是如何渲染的&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gityuan.com/2019/06/16/flutter_gpu_draw/&quot;&gt;Flutter渲染机制—GPU线程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/zhying719/article/details/108162396&quot;&gt;谈一谈Flutter外接纹理&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yuque.com/xytech/flutter/cqhql4&quot;&gt;Flutter初始化流程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yuque.com/xytech/flutter/tge705&quot;&gt;深入了解Flutter界面开发&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yuque.com/xytech/flutter/sh4fbm&quot;&gt;深入理解flutter的编译原理与优化&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yuque.com/xytech/flutter/fu7h25&quot;&gt;深入理解Flutter Platform Channel&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yuque.com/xytech/flutter/hc0xq7&quot;&gt;Flutter快速上车之Widget&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://flutter.cn/docs/resources/inside-flutter&quot;&gt;Flutter 工作原理&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://flutter.cn/docs/get-started/install&quot;&gt;Flutter 中文文档&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://flutter.cn/docs/resources/architectural-overview&quot;&gt;Flutter 架构概览&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://flutter.dev&quot;&gt;Flutter 文档&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://dart.cn&quot;&gt;Dart&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Nov 2020 18:30:00 +0800</pubDate>
        <link>http://junziboxue.com/new-to-flutter</link>
        <guid isPermaLink="true">http://junziboxue.com/new-to-flutter</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
      <item>
        <title>Flutter 透明渐变 AppBar</title>
        <description>&lt;p&gt;最近要用 Flutter 重构一个 Native 页面，效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/fadeAppBar.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随着页面滑动，圆形按钮逐渐消失，返回按钮逐渐呈现，同时AppBar的透明度在整个过程中，是随着滑动距离线性变化的，而按钮的变化分为两段：圆形按钮逐渐消失，返回按钮逐渐呈现，整个过程可逆。&lt;/p&gt;

&lt;p&gt;接下来介绍实现过程。&lt;/p&gt;

&lt;h4 id=&quot;1整体结构设计&quot;&gt;1.整体结构设计&lt;/h4&gt;

&lt;p&gt;通过观察可知，listView 可以在 AppBar 底部滑动，常规的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scaffold&lt;/code&gt; widget 无法满足这个需求，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt; widget 可以实现组件的叠加，在这里通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt; 作为页面的 root widget。通过监听scrollView 的滑动距离，实时计算 appBar 和 按钮 的透明度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt;///首先声明 全局变量
  AppBarWidget appBar;
  ScrollController scrollController; //scrollView的控制器
  PositionedBtnWidget roundLeftBtn; //圆形返回按钮
  PositionedBtnWidget rectLeftBtn;  //方形返回按钮
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在初始化方法里，给全局变量赋值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt; @override
  void initState() {
    super.initState();
    appBar = AppBarWidget();
    scrollController = ScrollController();
    roundLeftBtn = PositionedBtnWidget();
    rectLeftBtn = PositionedBtnWidget();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整体UI结构使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scaffold &lt;/code&gt;作为主框架，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;body&lt;/code&gt;部分则是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack &lt;/code&gt;，底部 TabBar使用 Scaffold 自带属性自定义搭建。为了适配 iPhoneX 底部，需要计算 安全区域高度。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; MediaQuery.of(context).padding.bottom;&lt;/code&gt; ，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CustomScrollView&lt;/code&gt; 的controller 继承自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChangeNotifier&lt;/code&gt;，可监听其位置变化。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;///示意代码
Scaffold(
        body: Stack(
          children: &amp;lt;Widget&amp;gt;[
            ///监听滚动
            NotificationListener(
              onNotification: (notification) {
                if (notification is ScrollUpdateNotification &amp;amp;&amp;amp;
                    notification.depth == 0) {
                  ///滑动通知
           scrollViewDidScrolled(notification.metrics.pixels);
                }
                ///通知不再上传
                return true;
              },
              child: CustomScrollView(),
            appBar,
            rectLeftBtn,
            roundLeftBtn,
          ],
        ),
        bottomNavigationBar: Container(
            color: Colors.orange,
            height: bottomBarHeight,
            child: Center(
              child: Text('bottom bar'),
            )));
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2其他部件的搭建&quot;&gt;2.其他部件的搭建&lt;/h4&gt;

&lt;p&gt;因为要实现透明度效果，这里使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Opacity&lt;/code&gt; widegt 来实现。控制 opacity 透明度的值，可实现透明度的变化。注意：在这里发现，Stack内的两个组件，如果发生重叠，位于顶部的widget最先响应点击事件。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;///示例
Opacity(
      opacity: opacity,
      child: Container(
        height: appBarHeight,
        child: AppBar(
          title: Text('app bar'),
          backgroundColor: Colors.deepOrange,
        ),
      ),
    );
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 Stack 内部，变动部件位置需要用到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Positioned&lt;/code&gt; widegt, 点击事件通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IconButton&lt;/code&gt; 来实现&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Positioned(
      top: btnTop,
      right: right,
      left: left,
      child: Opacity(
        opacity: btnOpacity,
        child: IconButton(
          icon: Image.asset(image),
          onPressed: () {
            if (widget != null &amp;amp;&amp;amp; widget.actionFunction != null) {
              widget.actionFunction();
            }
          },
        ),
      ),
    );
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3透明度计算&quot;&gt;3.透明度计算&lt;/h4&gt;

&lt;p&gt;通过监听 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scrollview&lt;/code&gt;的滑动距离，计算各个部件的透明度。
在这里 把完全透明到不透明 需要滑动的距离定为 80（单位逻辑像素 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logical pixels&lt;/code&gt;）
而按钮 的变化分为两段，每段滑动距离为整体的一半，也就是40逻辑像素。
具体计算方式如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; double maxOffset = 80.0;

  scrollViewDidScrolled(double offSet) {
    //print('scroll offset ' + offSet.toString());

    ///appbar 透明度
    double appBarOpacity = offSet / maxOffset;
    double halfPace = maxOffset / 2.0;

    ///圆形按钮透明度
    double roundOpacity = (halfPace - offSet) / halfPace;

    ///方形按钮透明度
    double rectOpacity = (offSet - halfPace) / halfPace;

    if (appBarOpacity &amp;lt; 0) {
      appBarOpacity = 0.0;
    } else if (appBarOpacity &amp;gt; 1) {
      appBarOpacity = 1.0;
    }

    if (roundOpacity &amp;lt; 0) {
      roundOpacity = 0.0;
    } else if (roundOpacity &amp;gt; 1) {
      roundOpacity = 1;
    }

    if (rectOpacity &amp;lt; 0) {
      rectOpacity = 0.0;
    } else if (rectOpacity &amp;gt; 1) {
      rectOpacity = 1.0;
    }
    //print('roundOpacity $roundOpacity rectOpacity $rectOpacity');

    ///更新透明度
    if (appBar != null &amp;amp;&amp;amp; appBar.updateAppBarOpacity != null) {
      appBar.updateAppBarOpacity(appBarOpacity);
    }

    if (roundLeftBtn != null &amp;amp;&amp;amp; roundLeftBtn.updateOpacity != null) {
      roundLeftBtn.updateOpacity(roundOpacity);
    }
    if (rectLeftBtn != null &amp;amp;&amp;amp; rectLeftBtn.updateOpacity != null) {
      rectLeftBtn.updateOpacity(rectOpacity);
    }
  }

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码地址&lt;br /&gt;
&lt;a href=&quot;https://github.com/JumpJumpSparrow/Flutter-FadeAppBar.git&quot;&gt;Demo&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 19 Aug 2020 18:30:00 +0800</pubDate>
        <link>http://junziboxue.com/flutter-fade-app-bar</link>
        <guid isPermaLink="true">http://junziboxue.com/flutter-fade-app-bar</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
      <item>
        <title>Jekyll 环境的搭建</title>
        <description>&lt;p&gt;最近换了台电脑，需要重新安装Jekyll环境，在这里记录下Mac安装Jekyell的过程。&lt;/p&gt;

&lt;h3 id=&quot;一环境准备&quot;&gt;一.环境准备&lt;/h3&gt;

&lt;p&gt;在安装Jekyll之前，需要具备以下条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Xcode 命令行&lt;/li&gt;
  &lt;li&gt;Homebrew&lt;/li&gt;
  &lt;li&gt;Ruby&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;1-homebrew&quot;&gt;1. Homebrew&lt;/h4&gt;

&lt;p&gt;什么是 &lt;a href=&quot;https://brew.sh&quot;&gt;Homebrew&lt;/a&gt; ?. 用一句话说明：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Homebrew installs the stuff you need that Apple (or your Linux system) didn’t.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/how-to-install-jekyll/homebrew.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Homebrow安装：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将以上内容粘贴到命令窗口，即可安装 Homebrew，中途可能需要输入用户密码。&lt;/p&gt;

&lt;h4 id=&quot;2-安装命令行工具&quot;&gt;2. 安装命令行工具&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;xcode-select --install
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果你已经安装了Xcode，无需进行此步。&lt;/p&gt;

&lt;h4 id=&quot;3安装ruby&quot;&gt;3.安装Ruby&lt;/h4&gt;

&lt;p&gt;Jekyll 需要 2.5.0以上版本的 Ruby，macOS Catalina 10.15 自带 ruby 2.6.3，如果你是之前的 mac 系统，需要更新下Ruby。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
brew install ruby

添加路径
echo 'export PATH=&quot;/usr/local/opt/ruby/bin:$PATH&quot;' &amp;gt;&amp;gt; ~/.bash_profile
echo 'export PATH=&quot;$HOME/.gem/ruby/X.X.0/bin:$PATH&quot;' &amp;gt;&amp;gt; ~/.bash_profile
‘X.X.0’为本地Ruby版本
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4安装jekyll&quot;&gt;4.安装Jekyll&lt;/h4&gt;

&lt;p&gt;安装 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bundler and Jekyll&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;gem install --user-install bundler jekyll
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;创建测试&quot;&gt;创建测试&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;jekyll new my-awesome-site
cd my-awesome-site
~/my-awesome-site $ bundle exec jekyll serve
# =&amp;gt; Now browse to http://localhost:4000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果已经创建 Jekyll，可能需要运行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gem update jekyll&lt;/code&gt;来更新Jekyll。
然后使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bundle update&lt;/code&gt;来更新依赖的包&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jekyllrb.com&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 10 Aug 2020 18:30:00 +0800</pubDate>
        <link>http://junziboxue.com/install-jekyll</link>
        <guid isPermaLink="true">http://junziboxue.com/install-jekyll</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
      <item>
        <title>深入了解 UINavigationController 的子控制器栈</title>
        <description>&lt;h3 id=&quot;1遇到一个需求&quot;&gt;1.遇到一个需求&lt;/h3&gt;
&lt;p&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController &lt;/code&gt;push进入多个页面后，不再显示部分页面，直接返回到指定的页面。&lt;/p&gt;

&lt;p&gt;根据描述，第一个想到的方案就是:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; [self.navigationController popToViewController:toVC animated:YES];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewControllers&lt;/code&gt;找到要跳转的页面，直接pop过去。&lt;/p&gt;

&lt;p&gt;遇到的问题就是，iOS 触发返回页面有两种交互方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;点击左上角的返回按钮&lt;/li&gt;
  &lt;li&gt;使用手势，在屏幕边缘从左往右滑动&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要想使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop&lt;/code&gt;的API，就需要拦截边缘滑动的交互事件，重写&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;的手势，（有的朋友说可以屏蔽右滑手势…）&lt;br /&gt;
由于不想改动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;的手势事件，遂有了下一个方案。&lt;/p&gt;

&lt;h3 id=&quot;2uinavigationcontroller实现原理&quot;&gt;2.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;实现原理&lt;/h3&gt;
&lt;p&gt;在iOS开发过程中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController &lt;/code&gt;是常用的容器类Controller，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController &lt;/code&gt;交互方式如下图，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/UINavigationController/navigation-interface.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据官方文档说明，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;通过管理一个用数组实现的栈结构来管理&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;childControllers &lt;/code&gt;。 将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;依次压入栈中，记录了页面的先后顺序，同时栈持有子视图，实现了内存的管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/UINavigationController/objects-managed-by-navi.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3解决方案&quot;&gt;3.解决方案&lt;/h3&gt;
&lt;p&gt;于是想到，通过修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;&lt;strong&gt;&lt;em&gt;栈内元素&lt;/em&gt;&lt;/strong&gt;来控制页面的跳转。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    NSMutableArray *vcStack = [NSMutableArray arrayWithArray:self.navigationController.viewControllers];
    if (vcStack.count &amp;gt; 2 &amp;amp;&amp;amp; vcStack.count &amp;gt; index) {
        //将 元素直接从 数组中 移除
        [vcStack removeObjectAtIndex:index];
        self.navigationController.viewControllers = vcStack;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样，在进入新的页面时，将不再显示的页面从栈中移除掉，便可实现跨页面的跳转。&lt;/p&gt;

&lt;p&gt;需要注意的是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当把一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;的实例push进栈后，该实例的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parentViewController&lt;/code&gt;就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (void)removeFromParentViewController&lt;/code&gt;方法，会将该实例从栈中移除，但会发生异常，具体表现为点击返回，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;navigationBar&lt;/code&gt; 有动画，但不会有页面跳转&lt;/li&gt;
  &lt;li&gt;注意内存的引用，如果要移除的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController &lt;/code&gt;在其他地方存在引用，将不会释放内存，发生内存泄露。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;附：UI结构图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/images/UINavigationController/views-of-navi.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uinavigationcontroller?language=objc&quot;&gt;UINavigationController&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 22 Jun 2020 18:30:00 +0800</pubDate>
        <link>http://junziboxue.com/ios-navigationcontroller</link>
        <guid isPermaLink="true">http://junziboxue.com/ios-navigationcontroller</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>批量并发-事件管理队列</title>
        <description>&lt;p&gt;首先描述一下背景：目前在做电商 APP 的页面改版，主要工作集中在商品详情页上。商品详情页的数据比较繁多，涉及到近 20 个网络接口。 这些接口中有的还存在依赖关系，而且重要程度也不尽相同。为了兼顾这些接口的并发性能和依赖关系，模仿 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 的接口设计，写了一个批量事件管理队列的工具 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;模型抽象&quot;&gt;模型抽象&lt;/h3&gt;

&lt;p&gt;商品详情页需要的数据有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;商品属性信息，包含商品ID、商品名、图册等等&lt;/li&gt;
  &lt;li&gt;商品销售信息，包含价格、销售状态、优惠信息&lt;/li&gt;
  &lt;li&gt;SKU/SPU 信息&lt;/li&gt;
  &lt;li&gt;商品运费信息&lt;/li&gt;
  &lt;li&gt;商品物流信息，最早可达时间信息&lt;/li&gt;
  &lt;li&gt;评价列表信息&lt;/li&gt;
  &lt;li&gt;推荐商品列表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里暂时列出这些&lt;/p&gt;

&lt;p&gt;根据以上列表不难看出，商品属性、销售信息和SKU/SPU信息最为重要，运费、物流信息次之，评价、推荐信息优先级最低。&lt;/p&gt;

&lt;p&gt;在这里，把所有事件分成多个批次，每个批次包含多个相互独立的事件，依次执行每个批次，
当优先级高的批次执行完之后，再执行优先级低的批次，如此形成一个队列。
因为执行队列保持顺序执行，依赖关系也被很好的隔离开来。
&lt;img src=&quot;/assets/article_assets/envent-schedule.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;由于多个事件分为多个批次执行，而且批次之间需要保持顺序，所以这里使用单向链表构建事件队列。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_assets/eventScheduleUML.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先创建一个 队列模型类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;，然后在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt; 的子类内部创建队列。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventUnit&lt;/code&gt;  事件类，包含唯一标志符、执行方法、执行状态。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventMark&lt;/code&gt;  队列节点类，包含事件集合、批次名称&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;  队列管理类&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleDelegate&lt;/code&gt; 队列回调事件&lt;/p&gt;

&lt;p&gt;创建子类继承&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;，在子类内部创建队列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)createSchedule {
    // 清空
    [self clearAllEvents];
    
    //第一阶段
    EventUnit *unit_1 = [EventUnit getEventWith:ProductDetailGetBasicInfo eventMethod:@&quot;ProductBasicInfo&quot;];

    EventMark *mark_1 = [EventMark getEventMarkWithEvents:@[unit_1]];
    mark_1.name = @&quot;第一阶段&quot;;
    
    [self push:mark_1];
    
    
    //第二阶段
    EventUnit *unit_2 = [EventUnit getEventWith:ProductDetailGetSaleInfo eventMethod:@&quot;ProductSaleInfo&quot;];
    EventUnit *unit_4 = [EventUnit getEventWith:ProductDetailItemUniqueInfo eventMethod:@&quot;ItemUniqueInfo&quot;];

    EventMark *mark_2 = [EventMark getEventMarkWithEvents:@[unit_2,unit_4]];
    mark_2.name = @&quot;第二阶段&quot;;
    
    [self push:mark_2];
    
    // 第一个 milestone 完成
    EventUnit *first = [EventUnit getEventWith:ProductDetailFirstStage eventMethod:@&quot;fistStageFinished&quot;];
    
    EventMark *firstMileStone = [EventMark getEventMarkWithEvents:@[first]];
    firstMileStone.name = @&quot;firstMileStone&quot;;
    
    [self push:firstMileStone];
    
    //第三阶段
    EventUnit *unit_8 = [EventUnit getEventWith:ProductDetailLogistics eventMethod:@&quot;LogisticsInfo&quot;];
    EventUnit *unit_9 = [EventUnit getEventWith:ProductDetailFreightInfo eventMethod:@&quot;FreightInfo&quot;];

    EventMark *mark_3 = [EventMark getEventMarkWithEvents:@[unit_8,unit_9]];
    mark_3.name = @&quot;第三阶段&quot;;
    
    [self push:mark_3];
    
    // 第二个 milestone 完成
    EventUnit *second = [EventUnit getEventWith:ProductDetailSecondStage eventMethod:@&quot;secondStageFinished&quot;];
    
    EventMark *secondMileStone = [EventMark getEventMarkWithEvents:@[second]];
    secondMileStone.name = @&quot;secondMileStone&quot;;
    
    [self push:secondMileStone];
    
    //第四阶段
    EventUnit *unit_10 = [EventUnit getEventWith:ProductDetailRecommend eventMethod:@&quot;RecommendInfo&quot;];
    EventUnit *unit_13 = [EventUnit getEventWith:ProductDetailComments eventMethod:@&quot;CommentsInfo&quot;];

    EventMark *mark_4 = [EventMark getEventMarkWithEvents:@[unit_10,unit_13]];
    mark_4.name = @&quot;第四阶段&quot;;
    
    [self push:mark_4];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父类执行方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;// 开始执行
- (void)start {
    
    EventMark *events = [self pop];
    
    if (events) {
        
        [self excuteEvents:events];
        
    } else {
        // 所有事件执行完毕
        _currentEvents = nil;
        if ([self.delegate respondsToSelector:@selector(allEventsFinished)]) {
            [self.delegate allEventsFinished];
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;// 执行事件
- (void)excuteEvents:(EventMark *)events{
    [self.lock lock];
    self.currentEvents = events;
    if ([self.delegate respondsToSelector:@selector(arriveOnEventSchedule:)]) {
        [self.delegate arriveOnEventSchedule:events];
    }
    [self.lock unlock];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在管理事件队列处，生成队列实例，创建队列，开启队列执行。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    self.scheduleManager = [[ProductDetailSchedule alloc] init];  
    self.scheduleManager.delegate = self;  
    // 创建队列
    [self.scheduleManager createSchedule];  
    [self.scheduleManager start];
    
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;事件方法执行, 这里根据字符串转方法，在子线程异步执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)arriveOnEventSchedule:(EventMark *)events{
    
    [events.events enumerateObjectsUsingBlock:^(EventUnit * _Nonnull obj, BOOL * _Nonnull stop) {
        
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                        
            SEL selector = NSSelectorFromString(obj.eventMethod);
            if ([self respondsToSelector:selector]) {
                
                IMP imp = [self methodForSelector:selector];
                void (*func)(id, SEL) = (void *)imp;
                func(self, selector);
            }
        });
    }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JumpJumpSparrow/EventScheduleManager.git&quot;&gt;Demo EventScheduleManager&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Dec 2019 07:00:00 +0800</pubDate>
        <link>http://junziboxue.com/concurrent-events-queue</link>
        <guid isPermaLink="true">http://junziboxue.com/concurrent-events-queue</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>解决 H5 页面在手机上布局异常的问题</title>
        <description>&lt;p&gt;目前在做一款电商 APP，在商品详情页中，使用 webview 呈现 H5 内容来展现商品的图文详情。测试反馈说 H5 内容呈现样式发生异常，经研究是手机尺寸与PC尺寸存在差异，CSS 无法完全适配导致的。&lt;/p&gt;

&lt;p&gt;如图，图片显示不完整 ⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_3.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;把 URL string 放到PC上展示如下：⤋&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_5.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;不难看出，这个详情页是把图片分割成多个部分，然后通过 CSS 布局拼接到一起的。&lt;/p&gt;

&lt;p&gt;拉伸 PC 浏览器窗口，可以看到我们想要的布局效果：⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_4.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;// html 中，图片宽度为 750 px，
// 为了铺满屏幕，计算 initial-scale 初始缩放比例
// html 中的尺寸为 750, 手机使用的不是物理像素，而是点；
    
CGFloat w = [[UIScreen mainScreen] bounds].size.width;
CGFloat ratio = w/750.0;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'UTF-8'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'viewport'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'width=device-width, initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0, user-scalable=0'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'format-detection'&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'telephone=no'&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为商品详情页在 PC 上的宽度为750像素， 我们根据手机频幕的宽度，计算出 H5 页面的缩放比例。&lt;br /&gt;
根据 H5 页面 头部 meta 信息，设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initial-scale&lt;/code&gt;初始缩放比例，通过注入 JS 调整初始缩放比例&lt;/p&gt;

&lt;p&gt;加载页面之前，注入一段 JS 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;CGFloat w = [[UIScreen mainScreen] bounds].size.width;
CGFloat ratio = w/750.0;

NSString *jScript = @&quot;var meta = document.createElement('meta'); meta.setAttribute('name', 'viewport'); meta.setAttribute('content', 'width=device-width,initial-scale=ratio,minimum-scale=0.30, maximum-scale=3.0, user-scalable=0'); meta.setAttribute('content', 'width=device-width'); document.getElementsByTagName('head')[0].appendChild(meta);&quot;;

jScript = [jScript stringByReplacingOccurrencesOfString:@&quot;ratio&quot; withString:[NSString stringWithFormat:@&quot;%f&quot;,ratio]];

WKUserScript *wkUScript = [[WKUserScript alloc] initWithSource:jScript injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];
WKUserContentController *wkUController = [[WKUserContentController alloc] init];
[wkUController addUserScript:wkUScript];

WKWebViewConfiguration *wkWebConfig = [[WKWebViewConfiguration alloc] init];
wkWebConfig.userContentController = wkUController;

wkWebV = [[WKWebView alloc] initWithFrame:self.view.frame configuration:wkWebConfig];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，webview 跟据当前 屏幕大小，自适应缩放 H5页面的大小。&lt;/p&gt;

&lt;p&gt;设置比例过小的效果图 ⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_2.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;设置缩放比例正确的效果 ⤋&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_1.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/26295277/wkwebview-equivalent-for-uiwebviews-scalespagetofit&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 18 Dec 2019 07:00:00 +0800</pubDate>
        <link>http://junziboxue.com/scales-pagesize-to-fit</link>
        <guid isPermaLink="true">http://junziboxue.com/scales-pagesize-to-fit</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>关于自动驾驶伦理问题的思考</title>
        <description>&lt;p&gt;  在这里主要讨论自动驾驶技术的实际应用中，可能遇到的社会伦理问题以及相关思考。&lt;/p&gt;

&lt;p&gt;  目前市场上已经出现了可以自动驾驶的汽车，比如特斯拉、百度的阿波龙。 其中自动驾驶应用较为激进的当属特斯拉无疑。近几年 (2016-2018) 特斯拉的几起事故，可能与自动驾驶技术尚未完全成熟有关。而百度已获得全国首批T4道路测试牌照，自动驾达到L4级别的&lt;a href=&quot;http://apollo.auto/minibus/index_cn.html&quot;&gt;阿波龙&lt;/a&gt;已经于2018年7月4日正式量产下线，已经在多地开始展开试用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/apollo.jpg&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（图为阿波龙自动驾驶汽车）&lt;/p&gt;

&lt;p&gt;  随着人工智能 AI (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Artificial Intelligence&lt;/code&gt;) 的事件处理能力和数据分析精度变得更强更高，自动驾驶技术也开始进入了实用阶段。当然，实现自动驾驶除了 AI 必不可少以外，还需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;计算机视觉&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;高精度地图&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5G高速通信技术&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;激光雷达&lt;/code&gt;等环境感知技术。可以预见到不久的将来，自动驾驶功能将会成为汽车的标配功能，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AI&lt;/code&gt; 也继 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;水&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;电&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;网络&lt;/code&gt;之后，势必成为生活中必不可少的基础元素，潜入到生活的方方面面。&lt;/p&gt;

&lt;p&gt;  然而 AI 作为自动驾驶的主要决策单元，代替驾驶员做出决策，控制车辆在道路上行走，这将带来一系列的社会伦理问题和法律问题。在这里列出一些自动驾驶在不久的将来可能会遇到的问题，与大家一起讨论、思考。&lt;/p&gt;

&lt;h4 id=&quot;问题1&quot;&gt;问题1&lt;/h4&gt;

&lt;p&gt;自动驾驶汽车行驶过程中，遇突发事故，选择避让可能危及行人生命安全，不避让可能会导致乘客伤亡，AI 该如何决策？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/user-innocent-accident.png&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有三个问题需要回答：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;用户&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;行人&lt;/em&gt;&lt;/strong&gt;都是无辜者，AI 有了干预的机会后，突来的意外应该降临到谁身上？&lt;/li&gt;
  &lt;li&gt;自动驾驶汽车作为一款产品，AI 是优先保护用户的安全？还是优先保护行人的安全？&lt;/li&gt;
  &lt;li&gt;遇到以上场景，自动驾驶是否需要&lt;strong&gt;&lt;em&gt;乘客&lt;/em&gt;&lt;/strong&gt;做出决策？或者说乘客的决定和AI的决定哪个有效？（自动驾驶里弱化了 司机 的角色，司机更多是 可以干预驾驶的乘客）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;问题2&quot;&gt;问题2&lt;/h4&gt;

&lt;p&gt;一辆火车失控，即将撞向铁路上的五个人，这时 AI 可以控制扳手让火车转向，撞向另外一条轨道上的一个人。是将伤亡将到最小，还是让事故继续发生？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/which-one-to-choose.png&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;人性、道德、法律，到底是谁做出了最终抉择？&lt;/p&gt;

&lt;p&gt;  这其实是美国哈佛大学政治哲学教授迈克尔·桑德尔，在公开课中设想的场景，用以描述行为选择的道德困境。在这里只是把人改为了 AI。在这里，不管 AI 如何处理，其最终决的选择实际来自于人，或者来自于人已经定制好的算法，AI 通过算法计算，忠实地执行了这个决定。&lt;/p&gt;

&lt;p&gt;  人可以为自己的决策和行为负责，那么AI的决策和行为谁来负责呢？&lt;/p&gt;

&lt;p&gt;  我认为这应该是社会群体层的共识问题，社会群体中的每个个体需要事先知晓 并接受 AI 的决策策略，在事故发生后， 所有人必须为算法的执行结果负责，因为这个是整个社会群体已经认可的选择。&lt;/p&gt;

&lt;p&gt;  当然 在现实中很难发生这种特殊情况，特别案例还需要根据实际情况具体分析，这里只是纯为讨论而假设的场景。&lt;/p&gt;

&lt;p&gt;自动驾驶不光光是 技术上的问题，法律和相关规范 是自动驾驶可以正常运行的必要条件。&lt;/p&gt;

&lt;p&gt;期待自动驾驶早点普及使用，在那之前，希望相关法律和规范已经落地执行。&lt;/p&gt;

&lt;p&gt;还有，没事不要到马路上溜达。&lt;/p&gt;

&lt;h3 id=&quot;end&quot;&gt;end&lt;/h3&gt;

&lt;p&gt;  写文章很有难度啊，写不下去了先在这里吐个槽，提升写作能力太有必要了。清楚明白地表达观点，并且让读者轻易的捕捉到你要表达的意思 ，让文章读起来感觉顺畅，同时保持整体有结构和层次，这些都不是那么容易的兼顾的到。想要提升写作能力，一番磨练必不可少啊。&lt;/p&gt;

&lt;p&gt;有问题或想法可以联系我讨论，邮箱：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;meowchunfat@hotmail.com&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;声明：本篇为个人原创，允许转载，转载请注明出处。&lt;/p&gt;
</description>
        <pubDate>Fri, 08 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://junziboxue.com/auto-pilot-ethics</link>
        <guid isPermaLink="true">http://junziboxue.com/auto-pilot-ethics</guid>
        
        <category>something</category>
        
        
      </item>
    
      <item>
        <title>iOS 关于 UIView 重绘的几个接口</title>
        <description>&lt;p&gt;在更新数据时，往往伴随着更新 UI 布局。如何触发系统去刷新 UI 绘制呢？以下方法你需要了解一下。&lt;/p&gt;

&lt;h3 id=&quot;setneedslayout&quot;&gt;setNeedsLayout&lt;/h3&gt;
&lt;p&gt;Invalidates the current layout of the receiver and triggers a layout update during the next update cycle.&lt;br /&gt;
Call this method on your application’s main thread when you want to adjust the layout of a view’s subviews. This method makes a note of the request and returns immediately. Because this method does not force an immediate update, but instead waits for the next update cycle, you can use it to invalidate the layout of multiple views before any of those views are updated. This behavior allows you to consolidate all of your layout updates to one update cycle, which is usually better for performance.&lt;/p&gt;

&lt;h3 id=&quot;layoutifneeded&quot;&gt;layoutIfNeeded&lt;/h3&gt;
&lt;p&gt;Recalculate the receiver’s layout, if required.&lt;/p&gt;

&lt;p&gt;When this message is received, the layer’s super layers are traversed until a ancestor layer is found that does not require layout. Then layout is performed on the entire layer-tree beneath that ancestor.&lt;/p&gt;

&lt;h3 id=&quot;layoutsubviews&quot;&gt;layoutSubviews&lt;/h3&gt;

&lt;p&gt;The default implementation of this method does nothing on iOS 5.1 and earlier. Otherwise, the default implementation uses any constraints you have set to determine the size and position of any subviews.&lt;/p&gt;

&lt;p&gt;Subclasses can override this method as needed to perform more precise layout of their subviews. You should override this method only if the autoresizing and constraint-based behaviors of the subviews do not offer the behavior you want. You can use your implementation to set the frame rectangles of your subviews directly.&lt;/p&gt;

&lt;p&gt;You should not call this method directly. If you want to force a layout update, call the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;setNeedsLayout&lt;/code&gt; method instead to do so prior to the next drawing update. If you want to update the layout of your views immediately, call the &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;layoutIfNeeded&lt;/code&gt; method.&lt;/p&gt;

&lt;h3 id=&quot;setneedsdisplay&quot;&gt;setNeedsDisplay&lt;/h3&gt;

&lt;p&gt;Recalculate the receiver’s layout, if required.&lt;br /&gt;
When this message is received, the layer’s super layers are traversed until a ancestor layer is found that does not require layout. Then layout is performed on the entire layer-tree beneath that ancestor.&lt;/p&gt;
</description>
        <pubDate>Fri, 18 Oct 2019 00:00:00 +0800</pubDate>
        <link>http://junziboxue.com/UIView-drawing-cycle</link>
        <guid isPermaLink="true">http://junziboxue.com/UIView-drawing-cycle</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>Building Objective-C static libraries with categories</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;Q:  How do I fix “selector not recognized” runtime exceptions when trying to use category methods from a static library?&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;如何解决 在 runtime 环境中尝试调用静态库中分类的方法时，报 “selector not recognized” 异常？&lt;/p&gt;

&lt;p&gt;  今天在浏览 YYKit 库时，一个宏定义引起了我的注意：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;YYSYNTH_DUMMY_CLASS &lt;/code&gt;,从字面意思看是定义了一个不起任何作用的&lt;em&gt;哑&lt;/em&gt;类。相关描述如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;/**
 Add this macro before each category implementation, so we don't have to use
 -all_load or -force_load to load object files from static libraries that only
 contain categories and no classes.
 More info: http://developer.apple.com/library/mac/#qa/qa2006/qa1490.html .
 *******************************************************************************
 Example:
     YYSYNTH_DUMMY_CLASS(NSString_YYAdd)
 */
#ifndef YYSYNTH_DUMMY_CLASS
#define YYSYNTH_DUMMY_CLASS(_name_) \
@interface YYSYNTH_DUMMY_CLASS_ ## _name_ : NSObject @end \
@implementation YYSYNTH_DUMMY_CLASS_ ## _name_ @end
#endif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;  根据 YYKit 作者的描述，在分类中加一个这样的宏定义可以避免一些复杂操作，具体原理作者并没有解释，只是给了一个苹果官方开发文档的连接。这个链接可能因为官方整理文档的原因，URL路径已经失效了。但是在官网搜索 URL 中的关键字找到了这篇&lt;a href=&quot;https://developer.apple.com/library/archive/qa/qa1490/_index.html&quot;&gt;资料&lt;/a&gt;。根据这篇资料在这里深入了解一下其中的原理和如何解决这类问题。&lt;/p&gt;

&lt;p&gt;官方文档以一个问题开篇，就是上面提出的那个问题，哈哈。接下来官方文档就给出了问题的解决方法：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;A: If you’re seeing a “selector not recognized” runtime exception when calling a category method that is implemented in a static library, you are hitting the link-time build issue described here, and need to add the -ObjC linker flag to your project, by following these steps:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;In Xcode, choose View &amp;gt; Navigators &amp;gt; Show Project Navigator, or press ⌘1.&lt;/li&gt;
    &lt;li&gt;Select your project under the PROJECT heading in the Project Navigator, then select the Build Settings tab.&lt;/li&gt;
    &lt;li&gt;Scroll down to the Other Linker Flags build setting under the Linking collection, or type “Other Linker Flags” into the search bar.&lt;/li&gt;
    &lt;li&gt;Set the value of the Other Linker Flags build setting to $(OTHER_LDFLAGS) -ObjC.&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;p&gt;译：当你在运行时调用一个在静态库中实现的分类的方法时，遇到 “selector not recognized” 运行时异常，那么你就撞到了本篇文档中描述的所谓的 “the link-time build issue” 问题，同时你需要在你的工程中加上 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-ObjC linker flag&lt;/code&gt; 来解决这个问题。具体步骤：(在这里就不翻译了么么哒)。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Figure 1:&lt;/em&gt;  Modifying the Other Linker Flags build setting.    &lt;br /&gt;
&lt;br /&gt;&lt;img src=&quot;/assets/article_assets/qa1490_other_linker_flags_xcode_5.png&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;troubleshooting&quot;&gt;Troubleshooting&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;If adding the -ObjC flag isn’t fixing the problem, double check that a conflicting Target build setting is not overriding it, by following the above steps, but selecting the current target under “TARGETS” in step 2, instead of the project.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;解决问题&quot;&gt;解决问题&lt;/h3&gt;
&lt;p&gt;  如果添加&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-ObjC flag&lt;/code&gt;没能解决这个问题，检查一下确保之前的操作没有与 Target build setting 冲突而使其无效。按照上面的步骤，在第二步时选择 &lt;em&gt;“TARGETS”&lt;/em&gt;下的target，而不是选择 project。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;other-causes-of-selector-not-recognized-exceptions&quot;&gt;Other Causes of selector not recognized Exceptions&lt;/h3&gt;
  &lt;p&gt;The most common causes of a “selector not recognized” exception are:&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;no-such-method&quot;&gt;No Such Method&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;The method really does not exist. Check your spelling. Check documentation to verify that the method exists on the version of the operating system your app is using.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;memory-management&quot;&gt;Memory Management&lt;/h3&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;Your app is trying to use an object after it has been deallocated, use the Zombies instrument to debug this kind of problem. You are seeing “selector not recognized” because the memory has been re-allocated as a different kind of object.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;导致selector-not-recognized-exceptions异常的其他原因&quot;&gt;导致&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;selector not recognized Exceptions&lt;/code&gt;异常的其他原因&lt;/h3&gt;
&lt;p&gt;  导致&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;selector not recognized Exceptions&lt;/code&gt;异常的原因通常是：&lt;/p&gt;
&lt;h4 id=&quot;方法不存在&quot;&gt;方法不存在&lt;/h4&gt;
&lt;p&gt;  方法实际上是不存在的。检查你的拼写是否有误。查阅文档，确保你调用的方法在当前版本的操作系统内存在。&lt;/p&gt;
&lt;h4 id=&quot;内存管理&quot;&gt;内存管理&lt;/h4&gt;
&lt;p&gt;  在对象已释放后，你的应用又尝试去访问它，原先存放对象的内存已被重新分配给其他类的对象，所以当你再次访问原先的对象时，就会发生 “selector not recognized”异常。使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Zombies instrument&lt;/code&gt;工具来debug这类问题。（这一段文档不通顺，稍作整理）&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h2 id=&quot;what-causes-those-exceptions&quot;&gt;What causes those exceptions?&lt;/h2&gt;
  &lt;p&gt;An impedance mismatch between UNIX static libraries and the dynamic nature of Objective-C can cause category methods in static libraries to not be linked into an app, resulting in “selector not recognized” exceptions when the methods aren’t found at runtime.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;导致这些异常的原因&quot;&gt;导致这些异常的原因&lt;/h2&gt;
&lt;p&gt;由于 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNIX static libraries&lt;/code&gt; 和 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dynamic nature of Objective-C&lt;/code&gt;不是很搭的原因，导致静态库中分类的方法不会被链接到app中去，以至于在 runtime 动态调用时无法找到方法，结果发生 “selector not recognized”异常。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;the-linker&quot;&gt;The Linker&lt;/h3&gt;
  &lt;p&gt;When a C program is compiled, each “source file” is turned into an “object file” that contains executable functions and static data. The linker glues these object files together into a final executable. That executable is eventually bundled into an app by Xcode.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;链接器&quot;&gt;链接器&lt;/h3&gt;
&lt;p&gt;当一个 C 程序被编译完成，所有”原文件”都被转换为”object file”，这些”object file”包含可执行方法和静态数据。链接器将这些”object file”粘合在一起，最终成为可执行文件。最终 Xcode 将这些可执行文件打包进APP中。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;When a source file uses something (like a function) defined in another file, then an undefined symbol is written into the object file, to “stand in” for the missing thing. The linker resolves these symbols by pulling in the object files that include definitions of undefined symbols when building the final executable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;当一个原文件调用某些在其他文件中定义的方法或者数据时，那么一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;未经定义的符号&lt;/code&gt;就被写入了 “object file”,用以代替缺失的方法或数据。在组成最终可执行文件时，链接器从那些包含 “undefined symbols” 定义的 “object files” 中抽取定义来解析这些符号。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example, if main.c uses the function foo(), where foo is defined in another file, B.c, then the object file main.o will have an unresolved symbol for foo(), and B.o will include an implementation of foo(). At link time, B.o will be brought into the final executable, so that the code in main.o now references the implementation of foo() defined in B.o.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;举个例子，假如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.c&lt;/code&gt; 调用方法 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo()&lt;/code&gt;,而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo&lt;/code&gt; 函数是在另一个文件 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B.c&lt;/code&gt; 中定义的，那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object file main.o&lt;/code&gt; 将会有一个未解析符号表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo()&lt;/code&gt;，同时 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B.o&lt;/code&gt; 将会包含 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo()&lt;/code&gt; 方法实现。在链接阶段，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B.o&lt;/code&gt; 将会被带入 最终执行文件，因此现在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.o&lt;/code&gt; 中的代码就可以引用在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;B.o&lt;/code&gt; 中对 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;foo()&lt;/code&gt; 的实现。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A UNIX static library is just a collection of object files. Normally the linker only pulls in an object file from a static library if doing so would resolve some undefined symbol. Not pulling in all object files reduces the size of the final executable.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;一个 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UNIX static library&lt;/code&gt; 只是将 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object files&lt;/code&gt; 集合在一起。链接器通常只会从&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;static library&lt;/code&gt;中提取那些包含&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undefined symbol&lt;/code&gt;解析的 object file，而不是把所有 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object files&lt;/code&gt; 都集成进来。这样可以减小最终可执行文件的体积。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;h3 id=&quot;objective-c&quot;&gt;Objective-C&lt;/h3&gt;
  &lt;p&gt;The dynamic nature of Objective-C complicates things slightly. Because the code that implements a method is not determined until the method is actually called, Objective-C does not define linker symbols for methods. Linker symbols are only defined for classes.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;objective-c-1&quot;&gt;Objective-C&lt;/h3&gt;

&lt;p&gt;O-C 的动态特性使这个过程略微复杂了一些。因为实现一个方法的代码直到这个方法被调用时才会被确定下来。Objective-C 并不为方法定义链接符号，链接符号只为 &lt;em&gt;类&lt;/em&gt; 进行定义。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;For example, if main.m includes the code [[FooClass alloc] initWithBar:nil]; then main.o will contain an undefined symbol for FooClass, but no linker symbols for the -initWithBar: method will be in main.o.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;比如： 假如 main.m 包含了这样的代码：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;[[FooClass alloc] initWithBar:nil];&lt;/code&gt;,那么 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.o&lt;/code&gt; 将会包含一个未定义符号表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;FooClass&lt;/code&gt;，但是在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;main.o&lt;/code&gt; 文件中，并不生成链接符号去表示 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-initWithBar:&lt;/code&gt; 方法。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Since categories are a collection of methods, using a category’s method does not generate an undefined symbol. This means the linker does not know to load an object file defining the category, if the class itself is already defined. This causes the same “selector not recognized” runtime exception you would see for any unimplemented method.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;因为分类是一组方法的集合，假如一个类已经定义了，在其中使用分类的方法并不生成 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;undefined symbol&lt;/code&gt;,这意味着链接器不知道需要去加载对应的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;object file&lt;/code&gt; 去定义分类。调用任何未实现的方法也一样会导致 “selector not recognized” 运行时异常。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;###The -ObjC Linker Flag
Passing the -ObjC option to the linker causes it to load all members of static libraries that implement any Objective-C class or category. This will pickup any category method implementations. But it can make the resulting executable larger, and may pickup unnecessary objects. For this reason it is not on by default.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;the--objc-linker-flag&quot;&gt;The -ObjC Linker Flag&lt;/h3&gt;
&lt;p&gt;指定 链接器的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;-ObjC&lt;/code&gt; 选项 可以使 链接器加载所有静态库总的成员，包括 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Objective-C&lt;/code&gt; 的类和分类。这将选入所有分类方法的实现。同时也使最最终的可执行文件体积更大，这也是为什么不作为默认选项。&lt;/p&gt;

&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;YYKit 中的这个宏定义在 分类之前加了一个空类，这样&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.m&lt;/code&gt;文件就包含了类，这样生成的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;.o&lt;/code&gt;文件就会被链接器打包进最终的可执行文件，从而避免了 “selector not recognized”异常的出现。&lt;/p&gt;

</description>
        <pubDate>Wed, 25 Sep 2019 02:00:00 +0800</pubDate>
        <link>http://junziboxue.com/yykit-micro</link>
        <guid isPermaLink="true">http://junziboxue.com/yykit-micro</guid>
        
        <category>iOS</category>
        
        
      </item>
    
  </channel>
</rss>
