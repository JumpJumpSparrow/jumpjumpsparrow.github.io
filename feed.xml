<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>CF Blog</title>
    <description>iOS 开发，会 1.5 点web前端，Java web入门开发者</description>
    <link>http://www.junziboxue.com/</link>
    <atom:link href="http://www.junziboxue.com/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Tue, 31 Oct 2023 16:21:11 +0800</pubDate>
    <lastBuildDate>Tue, 31 Oct 2023 16:21:11 +0800</lastBuildDate>
    <generator>Jekyll v4.3.2</generator>
    
      <item>
        <title>linux 常见命令</title>
        <description>&lt;p&gt;创建目录&lt;/p&gt;

&lt;h2 id=&quot;grep&quot;&gt;grep&lt;/h2&gt;

&lt;p&gt;全称是: Global Regular Expression Print&lt;/p&gt;

&lt;p&gt;文本搜索工具， 结合正则表达式使用&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/108042597&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&quot;awk&quot;&gt;AWK&lt;/h2&gt;

&lt;p&gt;取三位创始人 Alfred Aho，Peter Weinberger, 和 Brian Kernighan 的 Family Name 的首字符&lt;/p&gt;

&lt;p&gt;文本处理工具，格式化内容&lt;/p&gt;

&lt;h2 id=&quot;sed&quot;&gt;sed&lt;/h2&gt;

&lt;p&gt;Stream Editor&lt;/p&gt;

&lt;p&gt;流编辑器&lt;/p&gt;

&lt;h2 id=&quot;cat&quot;&gt;cat&lt;/h2&gt;

&lt;p&gt;concatenate&lt;/p&gt;

&lt;p&gt;创建单个或多个文件、查看文件内容、连接文件和重定向终端或文件中的输出&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Sep 2023 00:00:00 +0800</pubDate>
        <link>http://www.junziboxue.com/2023/09/07/linux-command/</link>
        <guid isPermaLink="true">http://www.junziboxue.com/2023/09/07/linux-command/</guid>
        
        <category>linux</category>
        
        
      </item>
    
      <item>
        <title>关于 AI 的一些思考</title>
        <description>&lt;h2 id=&quot;前言&quot;&gt;前言&lt;/h2&gt;
&lt;p&gt;趁ChatGPT的热度略微降下来，大部分人对AI的热情也过了新鲜期。人们在熟悉的AI的同时，也涌现了不少关于AI的意见和看法，这里聊一聊关于AI一些思考。&lt;/p&gt;

&lt;h2 id=&quot;一些铺垫&quot;&gt;一些铺垫&lt;/h2&gt;

&lt;p&gt;关于人工智能一直想说点什么，大概从2012年开始，一直保持对AI的断断续续的思考。从机器识别语音图像的基本智能，到AlphaGo，再到ChatGPT接近通用智能（AGI），AI的发展势头不可谓不迅猛。在AI的不同阶段，我对AI的看法和态度也发生了改变。&lt;/p&gt;

&lt;h2 id=&quot;开始阶段&quot;&gt;开始阶段&lt;/h2&gt;

&lt;p&gt;在20212年那时正读大二，和几个实验室同学跟导师聊技术方向的看法，当时我非常明确的表示，人工智能将会是改变世界的技术。那时的想法还是比较简单的，对AI的期望仅仅是创造极大的生产力，把人类从重复地、繁重地劳动中解放出来，所有人都可以拥有丰富的物质条件。这时人类的主要精力将会集中在发展自身兴趣和享受生命的美好。这个阶段，AI对我来说就是美好且单纯的，单纯地像没有被智慧污染的大学生。&lt;/p&gt;

&lt;h2 id=&quot;棋&quot;&gt;棋&lt;/h2&gt;

&lt;p&gt;从OCR，到图像识别，从语音识别，到语音生成，从国际象棋深蓝（DeepBlue），到围棋巅峰AlphaGo，人工智能发展的每一步，都使冰冷的机器渐渐有了更强的智力，一些方面的能力接近甚至超越了人类。回首AI的发展历程，自然而然的可以得出结论，AGI的诞生离不开各个方面的发展。数字媒体处理、机器视觉、逻辑处理、语言模型。看着各个领域的AI陆续取得里程碑式的发展结果，这个阶段，作为历史的参与者（其实是被历史的大浪无情地拍）对AI的发展还是比较迷茫的，AI研究结果一个接一个的涌现，&lt;/p&gt;

&lt;h2 id=&quot;大语言模型&quot;&gt;大语言模型&lt;/h2&gt;

&lt;h2 id=&quot;成本&quot;&gt;成本&lt;/h2&gt;
&lt;p&gt;AI是昂贵的，因为更强的智力意味着需要更高的算力，算力加速单元（GPU、计算加速卡、FPGA）等专业硬件设备采购成本非常高，动辄上千万、亿美刀。黄皮刀客（NVIDIA）市值超越intel，可见硬件的利润是很高的，也说明其采购成本是极高的。而且算力硬件每一两年就要更新换代，可以说硬件成本是一直要投入的。&lt;/p&gt;

&lt;p&gt;开发、研究人员的人力资源成本，AI的成本分要成两大部分的话，一部分是硬件，那另一部分就是人力资源成本。高级的研发人员薪资也很高级，往往会有股份分成和额外的奖金激励。&lt;/p&gt;

&lt;p&gt;有硬件和人力这两只吞金巨兽，也只有有集资能力的研究机构（高校、研究所）和头部企业（FLAG，openAI，MicroSoft，BAT）能在AI研究上持续投入。&lt;/p&gt;

&lt;h2 id=&quot;决策&quot;&gt;决策&lt;/h2&gt;
&lt;p&gt;AI是垄断的&lt;/p&gt;

&lt;h2 id=&quot;ai近乎独裁&quot;&gt;AI近乎独裁&lt;/h2&gt;

</description>
        <pubDate>Fri, 05 May 2023 00:00:00 +0800</pubDate>
        <link>http://www.junziboxue.com/2023/05/05/all-about-ai/</link>
        <guid isPermaLink="true">http://www.junziboxue.com/2023/05/05/all-about-ai/</guid>
        
        <category>AI</category>
        
        
      </item>
    
      <item>
        <title>WebRTC 信令交换与群聊实现</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/webRTC/WebRTC_Logo.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;1什么是-webrtc&quot;&gt;1.什么是 WebRTC&lt;/h2&gt;

&lt;p&gt;WebRTC，全称：(Web Real-Time Communication),是一个免费的开源工程。 &lt;br /&gt;
Google 把 WebRTC 视为和 HTTP 一样，不仅仅是一种解决方案，而是一种标准。&lt;br /&gt;
使各种终端，包括 浏览器、原生应用等具备音视频通讯和即时通讯的能力。&lt;/p&gt;

&lt;h3 id=&quot;11-webrtc术语&quot;&gt;1.1 webrtc术语&lt;/h3&gt;

&lt;p&gt;Signaling channel(信令通道)&lt;/p&gt;

&lt;p&gt;一种资源，使应用程序可以通过交换信令消息来发现，建立，控制和终止对等连接。信令消息是两个应用程序相互交换以建立对等连接的元数据。该元数据包括本地媒体信息，例如媒体编解码器和编解码器参数，以及两个应用程序可能相互连接以进行实时流传输的可能的网络候选路径。
PS：信令通道通常由信令服务器提供（或信令服务）&lt;/p&gt;

&lt;h4 id=&quot;peer对等节点&quot;&gt;Peer（对等节点）&lt;/h4&gt;

&lt;p&gt;接入同一webrtc房间（逻辑划分的管理单元）的进行实时双向流传输的任何设备或应用程序&lt;/p&gt;

&lt;h4 id=&quot;session-traversal-utilities-for-nat-stun&quot;&gt;Session Traversal Utilities for NAT (STUN)&lt;/h4&gt;

&lt;p&gt;一种协议，用于发现您的公共地址(公网IP)并确定路由器中可能阻止与对等方直接连接的任何限制条件。
PS：Stun服务由STUN服务器提供&lt;/p&gt;

&lt;h4 id=&quot;traversal-using-relays-around-nat-turn&quot;&gt;Traversal Using Relays around NAT (TURN)&lt;/h4&gt;

&lt;p&gt;通过打开与TURN服务器的连接并通过该服务器中继所有信息来绕过对称NAT限制的服务器。
PS：当P2P链接建立失败，仍需要保证功能可用，这里就需要TURN服务器对所有数据进行中继。建立relay模式的链接
PS: TURN服务由TURN服务器提供&lt;/p&gt;

&lt;h4 id=&quot;session-description-protocol-sdp&quot;&gt;Session Description Protocol (SDP)&lt;/h4&gt;

&lt;p&gt;一种描述连接的多媒体内容的标准，例如分辨率，格式，编解码器，加密等，以便一旦数据传输，两个对等方就可以相互理解。
PS:描述终端信息的规范。&lt;/p&gt;

&lt;h4 id=&quot;sdp-offer&quot;&gt;SDP Offer&lt;/h4&gt;

&lt;p&gt;发起建立会话链接的SDP消息(主动发送方)，生成会话描述以创建或修改会话。它描述了所需媒体通信的各个方面。
PS：比如想要和一个对等节点建立链接。首先就得告诉对端，自身终端信息（分辨率，格式，编解码器，加密），而为了描述自身终端信息产生SDP 就被称为SDP offer&lt;/p&gt;

&lt;h4 id=&quot;sdp-answer&quot;&gt;SDP Answer&lt;/h4&gt;

&lt;p&gt;answer SDP由响应者响应邀约者发送的offer SDP。Answer主要包含终端协商结果(answer端终端信息)。例如，如果offer中的所有音频和视频流都被接受。&lt;/p&gt;

&lt;h4 id=&quot;interactive-connectivity-establishment-ice&quot;&gt;Interactive Connectivity Establishment (ICE)&lt;/h4&gt;

&lt;p&gt;一个允许您的Web浏览器(webrtc终端)与对等方连接的框架。&lt;/p&gt;

&lt;p&gt;ICE Candidate(Candidate)
一种能与对等方用来通信的一种方法(方式)。&lt;/p&gt;

&lt;h3 id=&quot;12-stun-turn-ice如何工作&quot;&gt;1.2 STUN TURN ICE如何工作&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ClientA首先创建PeerConnection对象，然后打开本地音视频设备，将音视频数据封装成MediaStream添加到PeerConnection中。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ClientA调用PeerConnection的CreateOffer方法创建一个用于offer的SDP对象，SDP对象中保存当前音视频的相关参数。ClientA通过PeerConnection的SetLocalDescription方法将该SDP对象保存起来，并通过Signal服务器发送给ClientB。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ClientB接收到ClientA发送过的offer SDP对象，通过PeerConnection的SetRemoteDescription方法将其保存起来，并调用PeerConnection的CreateAnswer方法创建一个应答的SDP对象，通过PeerConnection的SetLocalDescription的方法保存该应答SDP对象并将它通过Signal服务器发送给ClientA。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ClientA接收到ClientB发送过来的应答SDP对象，将其通过PeerConnection的SetRemoteDescription方法保存起来。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;在SDP信息的offer/answer流程中，ClientA和ClientB已经根据SDP信息创建好相应的音频Channel和视频Channel并开启Candidate数据的收集，Candidate数据可以简单地理解成Client端的IP地址信息（本地IP地址、公网IP地址、Relay服务端分配的地址）。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;当ClientA收集到Candidate信息后，PeerConnection会通过OnIceCandidate接口给ClientA发送通知，ClientA将收到的Candidate信息通过Signal服务器发送给ClientB，ClientB通过PeerConnection的AddIceCandidate方法保存起来。同样的操作ClientB对ClientA再来一次。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;这样ClientA和ClientB就已经建立了音视频传输的P2P通道，ClientB接收到ClientA传送过来的音视频流，会通过PeerConnection的OnAddStream回调接口返回一个标识ClientA端音视频流的MediaStream对象，在ClientB端渲染出来即可。同样操作也适应ClientB到ClientA的音视频流的传输。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/webRTC/8fdbd5edc57ac9b4df227b875e1c0324.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;2安装接入&quot;&gt;2.安装接入&lt;/h2&gt;

&lt;p&gt;拿iOS来说，使用 webRTC 需要以下步骤：&lt;/p&gt;

&lt;h4 id=&quot;21-接入-webrtc-sdk&quot;&gt;2.1 接入 webRTC SDK&lt;/h4&gt;
&lt;p&gt;通过pods安装 webRTC sdk, 注意使用的是谷歌官方的 ‘GoogleWebRTC’ SDK&lt;br /&gt;
最新版本的 GoogleWebRTC SDK 需要 iOS 10.0以上，&lt;br /&gt;
因此工程需要设置为： iOS Deplopment Target 10.0&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;pod &apos;GoogleWebRTC&apos;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;22-工程设置&quot;&gt;2.2 工程设置&lt;/h4&gt;
&lt;p&gt;因为需要访问相机、麦克风等音视频设备，需要在工程中添加配置&lt;/p&gt;

&lt;p&gt;info.plist 文件中添加&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;//访问相机
&amp;lt;key&amp;gt;NSCameraUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;访问相机和拍照功能&amp;lt;/string&amp;gt;
//访问麦克风
&amp;lt;key&amp;gt;NSMicrophoneUsageDescription&amp;lt;/key&amp;gt;
&amp;lt;string&amp;gt;打开麦克风发送语音&amp;lt;/string&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;如果想在应用进入后台时，继续保持通话，还需要添加&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;音视频通话要额外添加
&amp;lt;key&amp;gt;UIBackgroundModes&amp;lt;/key&amp;gt;
	&amp;lt;array&amp;gt;
		&amp;lt;string&amp;gt;voip&amp;lt;/string&amp;gt;
	&amp;lt;/array&amp;gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;这个版本的 SDK 并不支持 bitcode,因此还需要关闭 bitCode,&lt;br /&gt;
在这里是以开发SDK的形式接入webRTC,因此需要以下设置&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Pods -&amp;gt; TARGETS -&amp;gt; XXX -&amp;gt; BuildSettings -&amp;gt; Build Options -&amp;gt; Enable Bitcode -&amp;gt;NO  
Pods -&amp;gt; TARGETS -&amp;gt; GoogleWebRTC -&amp;gt; BuildSettings -&amp;gt; Build Options -&amp;gt; Enable Bitcode -&amp;gt;NO
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;因为 视频通话使用 RTCMTLVideoView 渲染视频，其内部使用 Metal 图形接口来渲染图像，&lt;br /&gt;
该接口不支持ArmV7,因此需要在 valid Architecture 选项中 移除 arm v7指令集&lt;/p&gt;

&lt;h2 id=&quot;3-架构设计&quot;&gt;3. 架构设计&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;Factory 类：全局持有一个 RTCPeerConnectionFactory 类实例，管理本地 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCVideoTrack&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCAudioTrack&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCVideoSource&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCAudioSource&lt;/code&gt;,&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCCameraVideoCapturer&lt;/code&gt;等类的实例，以上类的实例都是全局唯一的。&lt;/li&gt;
  &lt;li&gt;Device 类: 控制本地 摄像头的开/关，前后摄像头的切换，音频输出 扬声器和听筒的切换。&lt;/li&gt;
  &lt;li&gt;RTCManager类: 负责管理所有 peer connection，包括生成、关闭、断线重连等功能&lt;/li&gt;
  &lt;li&gt;RTCClient 类：由 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCManager &lt;/code&gt;管理，负责 一个 Peer connection 的所有事务，包括webrtc的事件回调、生成/接收SDP和ICE信息.&lt;/li&gt;
  &lt;li&gt;RoomManager 类: 负责信令层的事务，管理通话事件.&lt;/li&gt;
  &lt;li&gt;AVChatManager 类: 对外暴露的接口类。外部统一由此类访问 音视频通话功能&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;注意事项：webRTC 生成的很多对象需要由外部持有，否则生成后会自动释放。如 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCVideoSource&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;RTCVideoTrack&lt;/code&gt;等&lt;/p&gt;

&lt;p&gt;事件集合：&lt;/p&gt;

&lt;h2 id=&quot;4群聊建立流程&quot;&gt;4.群聊建立流程&lt;/h2&gt;

&lt;p&gt;因为 WebRTC 是 P2P 连接，如果需要多人同时通信的话，就需要建立复杂的连接关系。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/webRTC/p2p_connection.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;如图，如果3个人通话，就需要建立 3条 P2P 连接，而4个人通话就需要 6 条P2P连接，5个人通话就需要 10条P2P连接。 &lt;br /&gt;
如果是 N 个人通话（N &amp;gt;= 3),就需要 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;N(N-3)/2 + N&lt;/code&gt; 条连接。人数越多，需要建立的连接会呈O(n^2)的趋势增长。&lt;br /&gt;
因此，P2P方案并不适合多人通讯，考虑到 终端 带宽和计算能力，要想保持高质量的音视频通话，人数上限大概在 6 个左右(参考微信)。 &lt;br /&gt;
超过6人 P2S 方案更适合。如果仅是音频通话的情况，那么 P2P 通话人数可以增加一个数量级（估计）。&lt;/p&gt;

&lt;p&gt;接下来说一下，如何建立起 多人通话的流程,此处已 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;A B C D&lt;/code&gt; 4人通话为例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/webRTC/p2p_topology.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;41-p2p连接流程&quot;&gt;4.1 P2P连接流程&lt;/h4&gt;

&lt;p&gt;假设 A 与 B建立连接. A 发起邀请等待 B 回复:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;B 接受后, Server 发送Accept信令给A&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A 接收到 ACCEPT信令后, 创建 PeerConnecton, 生成 OFFER, 返回给B,&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B接到OFFER后,创建与之对应的PeerConnecton,设置OFFER, 然后生成 ANSWER 返回给A.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;SDP 信息交换完毕后,交换ICE信息,连接完成.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;42-多端-p2p-连接建立流程&quot;&gt;4.2 多端 P2P 连接建立流程&lt;/h4&gt;

&lt;p&gt;假设 有 A B C D 四个客户端&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;A 向 B C D 发起邀请。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;假设 B C D 依次接受邀请，（无论是何种顺序，还是同时接受，这里都要串行处理）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;B 接受，同时给 A 发送 ACCEPT 信令。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;A 接到 B 发来的 ACCEPT 信令，A 发送 OFFER SDP 信息给B,
 B 返回 ANSWER SDP 给A, A　B交换ICE信息,A B 连接完毕.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;C 接受,  同时给 A B 发送 ACCEPT 信令,A B 发送 OFFER SDP 信息给C,
 C 返回 ANSWER SDP 给A B, AC BC交换ICE信息,A B C 连接完毕.&lt;/li&gt;
  &lt;li&gt;D 接受, 同时给 A B C发送 ACCEPT 信令,A B C发送 OFFER SDP 信息给D,
 D 返回 ANSWER SDP 给A B C, AD  BD CD交换ICE信息,A B C D 连接完毕.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;一次连接 对于邀请者来说,就算是发送一次 OFFER 和接到一次 ANSWER,对于被邀请者来说,就是接到 一次OFFER 和发送一次ANSWER.
一个PeerConnection 只能建立一次连接 不能建立两次连接（例如 不能重复的发送和接收同一个客户端的OFFER&lt;/p&gt;

&lt;h2 id=&quot;5-断线重连-机制&quot;&gt;5 断线重连 机制&lt;/h2&gt;
&lt;p&gt;假设 A B连接失败,A为主动发起对话的那方,&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;主动发起邀请的那方,销毁原先的 PeerConnection,&lt;/li&gt;
  &lt;li&gt;重新创建与B相对应的 Peer Connection,然后发送 OFFER SDP给 B,&lt;/li&gt;
  &lt;li&gt;B 收到 OFFER SDP 后,将B本地与A相对应的PeerConnection 销毁,&lt;/li&gt;
  &lt;li&gt;创建新的Peer Connection 与A对应,设置 OFFER SDP 后,&lt;/li&gt;
  &lt;li&gt;生成 ANSWER 返回给A，交换ICE　重新连接．&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;6-连接状态展示&quot;&gt;6. 连接状态展示&lt;/h2&gt;

&lt;p&gt;PC 间连接状态变化,通过&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;onconnectionstatechange&lt;/code&gt;接口回调获得.
共6种状态,分别是:&lt;/p&gt;

&lt;p&gt;“new”&lt;br /&gt;
“connecting”&lt;br /&gt;
“connected”&lt;br /&gt;
“disconnected”&lt;br /&gt;
“failed”&lt;br /&gt;
“closed”&lt;/p&gt;

&lt;p&gt;连接状态变化后,给出相应的提示文案.&lt;/p&gt;

&lt;h2 id=&quot;7多媒体控制&quot;&gt;7.多媒体控制&lt;/h2&gt;
&lt;p&gt;多媒体控制&lt;br /&gt;
1.镜头反转&lt;br /&gt;
2.静音/关闭摄像头&lt;br /&gt;
3.扬声器选择(听筒/外放)&lt;br /&gt;
4.画面分辨率选择(一般,清晰,高清)&lt;/p&gt;

&lt;p&gt;参考资料：&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://webrtc.github.io/samples/&quot;&gt;官方示例&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.cocoapods.org/pods/GoogleWebRTC&quot;&gt;Pods 安装&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://webrtc.org/?hl=en&quot;&gt;WebRTC 官网&lt;/a&gt;
&lt;a href=&quot;https://webrtc.org.cn/20190517_tutorial4_webrtc_ios/&quot;&gt;WebRTC 入门教程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://github.com/ChenYilong/WebRTC.git&quot;&gt;WebRTC入门教程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/m0_37263637/article/details/103999418&quot;&gt;WebRTC 连接建立&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://docs.aws.amazon.com/zh_cn/kinesisvideostreams-webrtc-dg/latest/devguide/kvswebrtc-how-it-works.html&quot;&gt;webRET 工作方式&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Mon, 11 Jan 2021 10:30:00 +0800</pubDate>
        <link>http://www.junziboxue.com/2021/01/11/webrtc-ios/</link>
        <guid isPermaLink="true">http://www.junziboxue.com/2021/01/11/webrtc-ios/</guid>
        
        <category>WebRTC</category>
        
        
      </item>
    
      <item>
        <title>从里到外，聊一聊 FLutter</title>
        <description>&lt;h3 id=&quot;1-什么是flutter&quot;&gt;1. 什么是flutter&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/new-to-flutter/whatIsFlutter.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Flutter 是 Google 开源的 UI 工具包，帮助开发者通过一套代码库,&lt;br /&gt;
高效构建多平台精美应用，支持移动、Web、桌面和嵌入式平台。&lt;/p&gt;

&lt;h4 id=&quot;11-flutter-优势&quot;&gt;1.1 flutter 优势&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;Flutter 很好的解决了跨端一致性问题，一套代码无差异的同时跑在 iOS 与 Android 两端；&lt;/li&gt;
  &lt;li&gt;开发体验基本接近前端.&lt;/li&gt;
  &lt;li&gt;支持 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;on device&lt;/code&gt; 的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hot Reload&lt;/code&gt; ，&lt;/li&gt;
  &lt;li&gt;Flutter 在 Android Studio 中通过插件实现实时预览并支持交互的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Hot UI&lt;/code&gt; 能力，以及&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; Layout Explorer&lt;/code&gt; 可视化布局，让Flutter 的开发效率和前端效率基本持平。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;a href=&quot;https://www.zhihu.com/question/374113031/answer/1252582543&quot;&gt;阿里巴巴淘系技术&lt;/a&gt;&lt;/p&gt;

&lt;h3 id=&quot;2-flutter-架构&quot;&gt;2. FLutter 架构&lt;/h3&gt;

&lt;p&gt;Flutter的整体架构共分为三层，从下到上分别为：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Embedder层&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine层&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Framework层&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/new-to-flutter/arch-diagram.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;分别对应：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Framework层：用Dart实现的上层UI SDK。&lt;/li&gt;
  &lt;li&gt;Engine层：渲染引擎层。&lt;/li&gt;
  &lt;li&gt;Embedder层：操作系统底层适配层。&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Framework&lt;/code&gt; 层：Dart实现的上层UI SDK
实现了：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Animation（动画&lt;/code&gt;）、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Painting（图形绘制）&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Gestures（手势操作）&lt;/code&gt;等功能，并包装成对应的 api 提供给上层开发者调用。为了保证Flutter所绘制的控件与原生控件风格类似，Flutter封装了&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Material&lt;/code&gt;（对应Android）、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Cupertino&lt;/code&gt;（对应iOS）风格的UI组件库，供开发者直接使用。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Engine&lt;/code&gt; 层：Skia渲染 + DartVM 引擎 &lt;br /&gt;
  这层主要包含三块：Skia、Dart、Text。&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;Skia 是渲染引擎，为 Framework 层提供“底层渲染”能力。&lt;/li&gt;
      &lt;li&gt;Dart 是 Dart 运行时引擎，为 Framework 层提供运行时调用Dart和渲染能力。&lt;/li&gt;
      &lt;li&gt;Text 是文字排版，为 Framework 层提供视图排版能力。&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Embedder&lt;/code&gt; 层：操作系统适配&lt;br /&gt;
对不同平台操作系统的适配，包括一些配置：surface、线程、插件等特性。
由于Flutter相关特性并不多，因此对不同平台操作系统的适配成本很低。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;3执行流程&quot;&gt;3.执行流程&lt;/h3&gt;

&lt;p&gt;从结构上看，Flutter渲染由UI Thread与GPU Thread相互配合完成。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/new-to-flutter/architect.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;1）UI Thread&lt;/p&gt;

&lt;p&gt;对应图中1-5，执行Dart VM中的Dart代码（包含应用程序和Flutter框架代码），主要负责Widget Tree、Element Tree、RenderObject Tree的构建，布局、以及绘制生成绘制指令，生成Layer Tree（保存绘制指令）等工作。&lt;/p&gt;

&lt;p&gt;2）GPU Thread&lt;/p&gt;

&lt;p&gt;对应图中6-7，执行Flutter引擎中图形相关代码（Skia），这个线程通过与GPU通信，获取Layer Tree并执行栅格化以及合成上屏等操作，将Layer Tree显示在屏幕上。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;注：图层树（Layer Tree）是Flutter组织绘制指令的方式， 
类似于Android Rendering里的View DisplayList，都是组织绘制指令的一种方式。
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;UI Thread与GPU Thread属于生产者和消费者的角色。&lt;/p&gt;

&lt;h3 id=&quot;flutter-渲染工作流水线&quot;&gt;Flutter 渲染工作流水线&lt;/h3&gt;

&lt;p&gt;渲染原理解释了 flutter 是如何跨平台的
&lt;img src=&quot;http://junziboxue.com/assets/images/new-to-flutter/rendering-pipline.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;渲染过程，UI线程完成布局、绘制操作，生成Layer Tree；
GPU线程执行合成并光栅化后交给GPU来处理，其中几个关键步骤：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Animate: 遍历_transientCallbacks，执行动画回调方法；&lt;/li&gt;
  &lt;li&gt;Build: 对于dirty的元素会执行build构造，没有dirty元素则不会执行，对应于buildScope()&lt;/li&gt;
  &lt;li&gt;Layout: 计算渲染对象的大小和位置，对应于flushLayout()，这个过程可能会嵌套再调用build操作；&lt;/li&gt;
  &lt;li&gt;Compositing bits: 更新具有脏合成位的任何渲染对象， 对应于flushCompositingBits()；&lt;/li&gt;
  &lt;li&gt;Paint: 将绘制命令记录到Layer， 对应于flushPaint()；&lt;/li&gt;
  &lt;li&gt;Compositing: 将Compositing bits发送给GPU， 对应于compositeFrame()；&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;GPU线程通过skia向GPU硬件绘制一帧的数据，GPU将帧信息保存到FrameBuffer里面，
然后视频控制器会根据VSync信号，从FrameBuffer取帧数据传递给显示器，从而显示出最终的画面。（Vulkan,OpenGL,Metal）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/new-to-flutter/render-flow.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;4渲染策略&quot;&gt;4.渲染策略&lt;/h3&gt;

&lt;p&gt;在Flutter中，Everything is widget。所有 Widget 会组成 Widget Tree 。&lt;br /&gt;
界面更新时，会更新 Widget Tree ，再更新 Element Tree ，最后更新 RenderObjectTree 。&lt;/p&gt;

&lt;p&gt;分为4个阶段，分别是：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;布局阶段 =&amp;gt; 绘制阶段 =&amp;gt; 合成阶段 =&amp;gt; 渲染阶段  
（Layout =&amp;gt; Paint =&amp;gt; Composite =&amp;gt; Rasterize）
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/new-to-flutter/layout-tree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;布局（Layout）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Flutter采用 “深度优先” 机制遍历Widget Tree。
 为了防止孩子节点的变化，导致整个 Widget Tree 重新布局。
 Flutter加入了 “布局边界” 机制（Relayout Boundary）
 布局完成后，树上每个节点都确定了“尺寸大小”和“位置”。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;绘制（Paint）&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;布局完成后，确定了树上的控件的“尺寸”与“位置”。
接下来是绘制阶段。&lt;/p&gt;

&lt;p&gt;和布局类似，Flutter也是采用 “深度优先” 机制遍历渲染树。
先绘制自身，再绘制子节点。
为了解决绘制覆盖问题，Flutter采用了也是和布局阶段相似的策略： 重绘边界 机制（Repaint Boundary）。
其实，本质上就是加个新的图层，避免在同一图层重绘产生影响。
典型的例子是，ScrollView。
一旦设置好重绘边界，滚动时，只会重绘ScollView中的视图内容，而其他部分不用重新绘制。&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;合成（Composite）
 由于绘制出来的渲染树，会有很多层，同步多层渲染会出现性能问题。&lt;br /&gt;
 因此，Flutter会在渲染前，将多个渲染树图层进行合成。&lt;br /&gt;
 根据多层渲染树的大小、层级、透明度等计算后， &lt;br /&gt;
 合成为最终“简化版”的渲染树，以提高下一步的渲染效率。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;渲染（Rasterize）
 将处理过的“简化版”渲染树，交给Skia引擎转换成“二维图像数据”。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;然后 Skia 把计算好的图形数据，通过 OpenGL 接口交给 GPU 渲染，走 GPU 工作流水线：
 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;顶点着色器 =&amp;gt; 形状装配 =&amp;gt; 几何着色器 =&amp;gt; 光栅化 =&amp;gt; 片段着色器 =&amp;gt; 测试与混合&lt;/code&gt;。&lt;br /&gt;
 然后，GPU工作流水线六阶段完成。最终，展示到终端屏幕上。&lt;br /&gt;
 当然这只是一个垂直同步信号（VSync）的过程。（按60fps算，一秒需要60个VSync才不会感到卡顿。）&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/new-to-flutter/full-pip-line.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;5工程实例讲解&quot;&gt;5.工程实例讲解&lt;/h3&gt;

&lt;h5 id=&quot;51常用组件&quot;&gt;5.1.常用组件&lt;/h5&gt;
&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/new-to-flutter/widget-tree.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h5 id=&quot;52特性展示&quot;&gt;5.2特性展示&lt;/h5&gt;

&lt;ul&gt;
  &lt;li&gt;4.1 hotReload&lt;/li&gt;
  &lt;li&gt;4.2 Android/iOS style&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;参考资料&lt;br /&gt;
&lt;a href=&quot;https://flutter.github.io/samples/#&quot;&gt;Flutter Samples&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://zhuanlan.zhihu.com/p/183770848?utm_source=wechat_session&quot;&gt;了解Flutter渲染机制&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.jianshu.com/p/8b0572f2c23a&quot;&gt;iOS 浅谈GPU及“App渲染流程”&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://juejin.im/post/6844904122257276936&quot;&gt;Flutter 究竟是如何渲染的&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;http://gityuan.com/2019/06/16/flutter_gpu_draw/&quot;&gt;Flutter渲染机制—GPU线程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://blog.csdn.net/zhying719/article/details/108162396&quot;&gt;谈一谈Flutter外接纹理&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yuque.com/xytech/flutter/cqhql4&quot;&gt;Flutter初始化流程&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yuque.com/xytech/flutter/tge705&quot;&gt;深入了解Flutter界面开发&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yuque.com/xytech/flutter/sh4fbm&quot;&gt;深入理解flutter的编译原理与优化&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yuque.com/xytech/flutter/fu7h25&quot;&gt;深入理解Flutter Platform Channel&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://www.yuque.com/xytech/flutter/hc0xq7&quot;&gt;Flutter快速上车之Widget&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://flutter.cn/docs/resources/inside-flutter&quot;&gt;Flutter 工作原理&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://flutter.cn/docs/get-started/install&quot;&gt;Flutter 中文文档&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://flutter.cn/docs/resources/architectural-overview&quot;&gt;Flutter 架构概览&lt;/a&gt;&lt;br /&gt;
&lt;a href=&quot;https://flutter.dev&quot;&gt;Flutter 文档&lt;/a&gt;  &lt;br /&gt;
&lt;a href=&quot;https://dart.cn&quot;&gt;Dart&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 02 Nov 2020 10:30:00 +0800</pubDate>
        <link>http://www.junziboxue.com/2020/11/02/new-to-flutter/</link>
        <guid isPermaLink="true">http://www.junziboxue.com/2020/11/02/new-to-flutter/</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
      <item>
        <title>Flutter 透明渐变 AppBar</title>
        <description>&lt;p&gt;最近要用 Flutter 重构一个 Native 页面，效果如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/fadeAppBar.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;随着页面滑动，圆形按钮逐渐消失，返回按钮逐渐呈现，同时AppBar的透明度在整个过程中，是随着滑动距离线性变化的，而按钮的变化分为两段：圆形按钮逐渐消失，返回按钮逐渐呈现，整个过程可逆。&lt;/p&gt;

&lt;p&gt;接下来介绍实现过程。&lt;/p&gt;

&lt;h4 id=&quot;1整体结构设计&quot;&gt;1.整体结构设计&lt;/h4&gt;

&lt;p&gt;通过观察可知，listView 可以在 AppBar 底部滑动，常规的 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scaffold&lt;/code&gt; widget 无法满足这个需求，而 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt; widget 可以实现组件的叠加，在这里通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack&lt;/code&gt; 作为页面的 root widget。通过监听scrollView 的滑动距离，实时计算 appBar 和 按钮 的透明度。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt;///首先声明 全局变量
  AppBarWidget appBar;
  ScrollController scrollController; //scrollView的控制器
  PositionedBtnWidget roundLeftBtn; //圆形返回按钮
  PositionedBtnWidget rectLeftBtn;  //方形返回按钮
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在初始化方法里，给全局变量赋值：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Dart&quot;&gt; @override
  void initState() {
    super.initState();
    appBar = AppBarWidget();
    scrollController = ScrollController();
    roundLeftBtn = PositionedBtnWidget();
    rectLeftBtn = PositionedBtnWidget();
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整体UI结构使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Scaffold &lt;/code&gt;作为主框架，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;body&lt;/code&gt;部分则是 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Stack &lt;/code&gt;，底部 TabBar使用 Scaffold 自带属性自定义搭建。为了适配 iPhoneX 底部，需要计算 安全区域高度。&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt; MediaQuery.of(context).padding.bottom;&lt;/code&gt; ，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;CustomScrollView&lt;/code&gt; 的controller 继承自 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ChangeNotifier&lt;/code&gt;，可监听其位置变化。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;///示意代码
Scaffold(
        body: Stack(
          children: &amp;lt;Widget&amp;gt;[
            ///监听滚动
            NotificationListener(
              onNotification: (notification) {
                if (notification is ScrollUpdateNotification &amp;amp;&amp;amp;
                    notification.depth == 0) {
                  ///滑动通知
           scrollViewDidScrolled(notification.metrics.pixels);
                }
                ///通知不再上传
                return true;
              },
              child: CustomScrollView(),
            appBar,
            rectLeftBtn,
            roundLeftBtn,
          ],
        ),
        bottomNavigationBar: Container(
            color: Colors.orange,
            height: bottomBarHeight,
            child: Center(
              child: Text(&apos;bottom bar&apos;),
            )));
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;2其他部件的搭建&quot;&gt;2.其他部件的搭建&lt;/h4&gt;

&lt;p&gt;因为要实现透明度效果，这里使用 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Opacity&lt;/code&gt; widegt 来实现。控制 opacity 透明度的值，可实现透明度的变化。注意：在这里发现，Stack内的两个组件，如果发生重叠，位于顶部的widget最先响应点击事件。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;///示例
Opacity(
      opacity: opacity,
      child: Container(
        height: appBarHeight,
        child: AppBar(
          title: Text(&apos;app bar&apos;),
          backgroundColor: Colors.deepOrange,
        ),
      ),
    );
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;在 Stack 内部，变动部件位置需要用到 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Positioned&lt;/code&gt; widegt, 点击事件通过 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;IconButton&lt;/code&gt; 来实现&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;Positioned(
      top: btnTop,
      right: right,
      left: left,
      child: Opacity(
        opacity: btnOpacity,
        child: IconButton(
          icon: Image.asset(image),
          onPressed: () {
            if (widget != null &amp;amp;&amp;amp; widget.actionFunction != null) {
              widget.actionFunction();
            }
          },
        ),
      ),
    );
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;3透明度计算&quot;&gt;3.透明度计算&lt;/h4&gt;

&lt;p&gt;通过监听 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;scrollview&lt;/code&gt;的滑动距离，计算各个部件的透明度。
在这里 把完全透明到不透明 需要滑动的距离定为 80（单位逻辑像素 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;logical pixels&lt;/code&gt;）
而按钮 的变化分为两段，每段滑动距离为整体的一半，也就是40逻辑像素。
具体计算方式如下：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; double maxOffset = 80.0;

  scrollViewDidScrolled(double offSet) {
    //print(&apos;scroll offset &apos; + offSet.toString());

    ///appbar 透明度
    double appBarOpacity = offSet / maxOffset;
    double halfPace = maxOffset / 2.0;

    ///圆形按钮透明度
    double roundOpacity = (halfPace - offSet) / halfPace;

    ///方形按钮透明度
    double rectOpacity = (offSet - halfPace) / halfPace;

    if (appBarOpacity &amp;lt; 0) {
      appBarOpacity = 0.0;
    } else if (appBarOpacity &amp;gt; 1) {
      appBarOpacity = 1.0;
    }

    if (roundOpacity &amp;lt; 0) {
      roundOpacity = 0.0;
    } else if (roundOpacity &amp;gt; 1) {
      roundOpacity = 1;
    }

    if (rectOpacity &amp;lt; 0) {
      rectOpacity = 0.0;
    } else if (rectOpacity &amp;gt; 1) {
      rectOpacity = 1.0;
    }
    //print(&apos;roundOpacity $roundOpacity rectOpacity $rectOpacity&apos;);

    ///更新透明度
    if (appBar != null &amp;amp;&amp;amp; appBar.updateAppBarOpacity != null) {
      appBar.updateAppBarOpacity(appBarOpacity);
    }

    if (roundLeftBtn != null &amp;amp;&amp;amp; roundLeftBtn.updateOpacity != null) {
      roundLeftBtn.updateOpacity(roundOpacity);
    }
    if (rectLeftBtn != null &amp;amp;&amp;amp; rectLeftBtn.updateOpacity != null) {
      rectLeftBtn.updateOpacity(rectOpacity);
    }
  }

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;代码地址&lt;br /&gt;
&lt;a href=&quot;https://github.com/JumpJumpSparrow/Flutter-FadeAppBar.git&quot;&gt;Demo&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Wed, 19 Aug 2020 10:30:00 +0800</pubDate>
        <link>http://www.junziboxue.com/2020/08/19/flutter-fade-app-bar/</link>
        <guid isPermaLink="true">http://www.junziboxue.com/2020/08/19/flutter-fade-app-bar/</guid>
        
        <category>Flutter</category>
        
        
      </item>
    
      <item>
        <title>Jekyll 环境的搭建</title>
        <description>&lt;p&gt;最近换了台电脑，需要重新安装Jekyll环境，在这里记录下Mac安装Jekyell的过程。&lt;/p&gt;

&lt;h3 id=&quot;一环境准备&quot;&gt;一.环境准备&lt;/h3&gt;

&lt;p&gt;在安装Jekyll之前，需要具备以下条件：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Xcode 命令行&lt;/li&gt;
  &lt;li&gt;Homebrew&lt;/li&gt;
  &lt;li&gt;Ruby&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;1-homebrew&quot;&gt;1. Homebrew&lt;/h4&gt;

&lt;p&gt;什么是 &lt;a href=&quot;https://brew.sh&quot;&gt;Homebrew&lt;/a&gt; ?. 用一句话说明：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Homebrew installs the stuff you need that Apple (or your Linux system) didn’t.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/how-to-install-jekyll/homebrew.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Homebrow安装：&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/bin/bash -c &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)&quot;

&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;将以上内容粘贴到命令窗口，即可安装 Homebrew，中途可能需要输入用户密码。&lt;/p&gt;

&lt;h4 id=&quot;2-安装命令行工具&quot;&gt;2. 安装命令行工具&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;xcode-select --install
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果你已经安装了Xcode，无需进行此步。&lt;/p&gt;

&lt;h4 id=&quot;3安装ruby&quot;&gt;3.安装Ruby&lt;/h4&gt;

&lt;p&gt;Jekyll 需要 2.5.0以上版本的 Ruby，macOS Catalina 10.15 自带 ruby 2.6.3，如果你是之前的 mac 系统，需要更新下Ruby。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
7
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
brew install ruby

添加路径
echo &apos;export PATH=&quot;/usr/local/opt/ruby/bin:$PATH&quot;&apos; &amp;gt;&amp;gt; ~/.bash_profile
echo &apos;export PATH=&quot;$HOME/.gem/ruby/X.X.0/bin:$PATH&quot;&apos; &amp;gt;&amp;gt; ~/.bash_profile
‘X.X.0’为本地Ruby版本
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;4安装jekyll&quot;&gt;4.安装Jekyll&lt;/h4&gt;

&lt;p&gt;安装 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Bundler and Jekyll&lt;/code&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;gem install --user-install bundler jekyll
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;创建测试&quot;&gt;创建测试&lt;/h3&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;jekyll new my-awesome-site
cd my-awesome-site
~/my-awesome-site $ bundle exec jekyll serve
# =&amp;gt; Now browse to http://localhost:4000
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;如果已经创建 Jekyll，可能需要运行 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;gem update jekyll&lt;/code&gt;来更新Jekyll。
然后使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;bundle update&lt;/code&gt;来更新依赖的包&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://jekyllrb.com&quot;&gt;参考资料&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 10 Aug 2020 10:30:00 +0800</pubDate>
        <link>http://www.junziboxue.com/2020/08/10/install-jekyll/</link>
        <guid isPermaLink="true">http://www.junziboxue.com/2020/08/10/install-jekyll/</guid>
        
        <category>jekyll</category>
        
        
      </item>
    
      <item>
        <title>深入了解 UINavigationController 的子控制器栈</title>
        <description>&lt;h3 id=&quot;1遇到一个需求&quot;&gt;1.遇到一个需求&lt;/h3&gt;
&lt;p&gt;使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController &lt;/code&gt;push进入多个页面后，不再显示部分页面，直接返回到指定的页面。&lt;/p&gt;

&lt;p&gt;根据描述，第一个想到的方案就是:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt; [self.navigationController popToViewController:toVC animated:YES];
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;通过遍历&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;viewControllers&lt;/code&gt;找到要跳转的页面，直接pop过去。&lt;/p&gt;

&lt;p&gt;遇到的问题就是，iOS 触发返回页面有两种交互方式：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;点击左上角的返回按钮&lt;/li&gt;
  &lt;li&gt;使用手势，在屏幕边缘从左往右滑动&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;要想使用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;pop&lt;/code&gt;的API，就需要拦截边缘滑动的交互事件，重写&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;的手势，（有的朋友说可以屏蔽右滑手势…）&lt;br /&gt;
由于不想改动 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;的手势事件，遂有了下一个方案。&lt;/p&gt;

&lt;h3 id=&quot;2uinavigationcontroller实现原理&quot;&gt;2.&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;实现原理&lt;/h3&gt;
&lt;p&gt;在iOS开发过程中，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController &lt;/code&gt;是常用的容器类Controller，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController &lt;/code&gt;交互方式如下图，&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/UINavigationController/navigation-interface.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;根据官方文档说明，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;通过管理一个用数组实现的栈结构来管理&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;childControllers &lt;/code&gt;。 将&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;依次压入栈中，记录了页面的先后顺序，同时栈持有子视图，实现了内存的管理。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/UINavigationController/objects-managed-by-navi.jpeg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;3解决方案&quot;&gt;3.解决方案&lt;/h3&gt;
&lt;p&gt;于是想到，通过修改&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;&lt;strong&gt;&lt;em&gt;栈内元素&lt;/em&gt;&lt;/strong&gt;来控制页面的跳转。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    NSMutableArray *vcStack = [NSMutableArray arrayWithArray:self.navigationController.viewControllers];
    if (vcStack.count &amp;gt; 2 &amp;amp;&amp;amp; vcStack.count &amp;gt; index) {
        //将 元素直接从 数组中 移除
        [vcStack removeObjectAtIndex:index];
        self.navigationController.viewControllers = vcStack;
    }
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;这样，在进入新的页面时，将不再显示的页面从栈中移除掉，便可实现跨页面的跳转。&lt;/p&gt;

&lt;p&gt;需要注意的是：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;当把一个&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;的实例push进栈后，该实例的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;parentViewController&lt;/code&gt;就是&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UINavigationController&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;调用&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController&lt;/code&gt;的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;- (void)removeFromParentViewController&lt;/code&gt;方法，会将该实例从栈中移除，但会发生异常，具体表现为点击返回，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;navigationBar&lt;/code&gt; 有动画，但不会有页面跳转&lt;/li&gt;
  &lt;li&gt;注意内存的引用，如果要移除的&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;UIViewController &lt;/code&gt;在其他地方存在引用，将不会释放内存，发生内存泄露。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;附：UI结构图&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://junziboxue.com/assets/images/UINavigationController/views-of-navi.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;参考资料：&lt;br /&gt;
&lt;a href=&quot;https://developer.apple.com/documentation/uikit/uinavigationcontroller?language=objc&quot;&gt;UINavigationController&lt;/a&gt;&lt;/p&gt;

</description>
        <pubDate>Mon, 22 Jun 2020 10:30:00 +0800</pubDate>
        <link>http://www.junziboxue.com/2020/06/22/ios-navigationcontroller/</link>
        <guid isPermaLink="true">http://www.junziboxue.com/2020/06/22/ios-navigationcontroller/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>批量并发-事件管理队列</title>
        <description>&lt;p&gt;首先描述一下背景：目前在做电商 APP 的页面改版，主要工作集中在商品详情页上。商品详情页的数据比较繁多，涉及到近 20 个网络接口。 这些接口中有的还存在依赖关系，而且重要程度也不尽相同。为了兼顾这些接口的并发性能和依赖关系，模仿 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;dispatch_group&lt;/code&gt; 的接口设计，写了一个批量事件管理队列的工具 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt; 。&lt;/p&gt;

&lt;h3 id=&quot;模型抽象&quot;&gt;模型抽象&lt;/h3&gt;

&lt;p&gt;商品详情页需要的数据有：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;商品属性信息，包含商品ID、商品名、图册等等&lt;/li&gt;
  &lt;li&gt;商品销售信息，包含价格、销售状态、优惠信息&lt;/li&gt;
  &lt;li&gt;SKU/SPU 信息&lt;/li&gt;
  &lt;li&gt;商品运费信息&lt;/li&gt;
  &lt;li&gt;商品物流信息，最早可达时间信息&lt;/li&gt;
  &lt;li&gt;评价列表信息&lt;/li&gt;
  &lt;li&gt;推荐商品列表&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;这里暂时列出这些&lt;/p&gt;

&lt;p&gt;根据以上列表不难看出，商品属性、销售信息和SKU/SPU信息最为重要，运费、物流信息次之，评价、推荐信息优先级最低。&lt;/p&gt;

&lt;p&gt;在这里，把所有事件分成多个批次，每个批次包含多个相互独立的事件，依次执行每个批次，
当优先级高的批次执行完之后，再执行优先级低的批次，如此形成一个队列。
因为执行队列保持顺序执行，依赖关系也被很好的隔离开来。
&lt;img src=&quot;/assets/article_assets/envent-schedule.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;代码实现&quot;&gt;代码实现&lt;/h3&gt;

&lt;p&gt;由于多个事件分为多个批次执行，而且批次之间需要保持顺序，所以这里使用单向链表构建事件队列。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/article_assets/eventScheduleUML.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;首先创建一个 队列模型类 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;，然后在 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt; 的子类内部创建队列。&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventUnit&lt;/code&gt;  事件类，包含唯一标志符、执行方法、执行状态。&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventMark&lt;/code&gt;  队列节点类，包含事件集合、批次名称&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;  队列管理类&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleDelegate&lt;/code&gt; 队列回调事件&lt;/p&gt;

&lt;p&gt;创建子类继承&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;EventScheduleManager&lt;/code&gt;，在子类内部创建队列：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)createSchedule {
    // 清空
    [self clearAllEvents];
    
    //第一阶段
    EventUnit *unit_1 = [EventUnit getEventWith:ProductDetailGetBasicInfo eventMethod:@&quot;ProductBasicInfo&quot;];

    EventMark *mark_1 = [EventMark getEventMarkWithEvents:@[unit_1]];
    mark_1.name = @&quot;第一阶段&quot;;
    
    [self push:mark_1];
    
    
    //第二阶段
    EventUnit *unit_2 = [EventUnit getEventWith:ProductDetailGetSaleInfo eventMethod:@&quot;ProductSaleInfo&quot;];
    EventUnit *unit_4 = [EventUnit getEventWith:ProductDetailItemUniqueInfo eventMethod:@&quot;ItemUniqueInfo&quot;];

    EventMark *mark_2 = [EventMark getEventMarkWithEvents:@[unit_2,unit_4]];
    mark_2.name = @&quot;第二阶段&quot;;
    
    [self push:mark_2];
    
    // 第一个 milestone 完成
    EventUnit *first = [EventUnit getEventWith:ProductDetailFirstStage eventMethod:@&quot;fistStageFinished&quot;];
    
    EventMark *firstMileStone = [EventMark getEventMarkWithEvents:@[first]];
    firstMileStone.name = @&quot;firstMileStone&quot;;
    
    [self push:firstMileStone];
    
    //第三阶段
    EventUnit *unit_8 = [EventUnit getEventWith:ProductDetailLogistics eventMethod:@&quot;LogisticsInfo&quot;];
    EventUnit *unit_9 = [EventUnit getEventWith:ProductDetailFreightInfo eventMethod:@&quot;FreightInfo&quot;];

    EventMark *mark_3 = [EventMark getEventMarkWithEvents:@[unit_8,unit_9]];
    mark_3.name = @&quot;第三阶段&quot;;
    
    [self push:mark_3];
    
    // 第二个 milestone 完成
    EventUnit *second = [EventUnit getEventWith:ProductDetailSecondStage eventMethod:@&quot;secondStageFinished&quot;];
    
    EventMark *secondMileStone = [EventMark getEventMarkWithEvents:@[second]];
    secondMileStone.name = @&quot;secondMileStone&quot;;
    
    [self push:secondMileStone];
    
    //第四阶段
    EventUnit *unit_10 = [EventUnit getEventWith:ProductDetailRecommend eventMethod:@&quot;RecommendInfo&quot;];
    EventUnit *unit_13 = [EventUnit getEventWith:ProductDetailComments eventMethod:@&quot;CommentsInfo&quot;];

    EventMark *mark_4 = [EventMark getEventMarkWithEvents:@[unit_10,unit_13]];
    mark_4.name = @&quot;第四阶段&quot;;
    
    [self push:mark_4];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;父类执行方法&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;// 开始执行
- (void)start {
    
    EventMark *events = [self pop];
    
    if (events) {
        
        [self excuteEvents:events];
        
    } else {
        // 所有事件执行完毕
        _currentEvents = nil;
        if ([self.delegate respondsToSelector:@selector(allEventsFinished)]) {
            [self.delegate allEventsFinished];
        }
    }
}

&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;// 执行事件
- (void)excuteEvents:(EventMark *)events{
    [self.lock lock];
    self.currentEvents = events;
    if ([self.delegate respondsToSelector:@selector(arriveOnEventSchedule:)]) {
        [self.delegate arriveOnEventSchedule:events];
    }
    [self.lock unlock];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在管理事件队列处，生成队列实例，创建队列，开启队列执行。&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
4
5
6
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;    self.scheduleManager = [[ProductDetailSchedule alloc] init];  
    self.scheduleManager.delegate = self;  
    // 创建队列
    [self.scheduleManager createSchedule];  
    [self.scheduleManager start];
    
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;事件方法执行, 这里根据字符串转方法，在子线程异步执行&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-Objective-C&quot;&gt;- (void)arriveOnEventSchedule:(EventMark *)events{
    
    [events.events enumerateObjectsUsingBlock:^(EventUnit * _Nonnull obj, BOOL * _Nonnull stop) {
        
        dispatch_async(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_DEFAULT, 0), ^{
                        
            SEL selector = NSSelectorFromString(obj.eventMethod);
            if ([self respondsToSelector:selector]) {
                
                IMP imp = [self methodForSelector:selector];
                void (*func)(id, SEL) = (void *)imp;
                func(self, selector);
            }
        });
    }];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/JumpJumpSparrow/EventScheduleManager.git&quot;&gt;Demo EventScheduleManager&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Dec 2019 23:00:00 +0800</pubDate>
        <link>http://www.junziboxue.com/2019/12/17/concurrent-events-queue/</link>
        <guid isPermaLink="true">http://www.junziboxue.com/2019/12/17/concurrent-events-queue/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>解决 H5 页面在手机上布局异常的问题</title>
        <description>&lt;p&gt;目前在做一款电商 APP，在商品详情页中，使用 webview 呈现 H5 内容来展现商品的图文详情。测试反馈说 H5 内容呈现样式发生异常，经研究是手机尺寸与PC尺寸存在差异，CSS 无法完全适配导致的。&lt;/p&gt;

&lt;p&gt;如图，图片显示不完整 ⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_3.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;把 URL string 放到PC上展示如下：⤋&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_5.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;不难看出，这个详情页是把图片分割成多个部分，然后通过 CSS 布局拼接到一起的。&lt;/p&gt;

&lt;p&gt;拉伸 PC 浏览器窗口，可以看到我们想要的布局效果：⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_4.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;// html 中，图片宽度为 750 px，
// 为了铺满屏幕，计算 initial-scale 初始缩放比例
// html 中的尺寸为 750, 手机使用的不是物理像素，而是点；
    
CGFloat w = [[UIScreen mainScreen] bounds].size.width;
CGFloat ratio = w/750.0;
&lt;/code&gt;&lt;/pre&gt;
&lt;div class=&quot;language-html highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;table class=&quot;rouge-table&quot;&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td class=&quot;rouge-gutter gl&quot;&gt;&lt;pre class=&quot;lineno&quot;&gt;1
2
3
&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;rouge-code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;charset=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;UTF-8&apos;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;viewport&apos;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;width=device-width, initial-scale=1.0,minimum-scale=1.0, maximum-scale=1.0, user-scalable=0&apos;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;nt&quot;&gt;&amp;lt;meta&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;name=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;format-detection&apos;&lt;/span&gt; &lt;span class=&quot;na&quot;&gt;content=&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&apos;telephone=no&apos;&lt;/span&gt;&lt;span class=&quot;nt&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;因为商品详情页在 PC 上的宽度为750像素， 我们根据手机频幕的宽度，计算出 H5 页面的缩放比例。&lt;br /&gt;
根据 H5 页面 头部 meta 信息，设置 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;initial-scale&lt;/code&gt;初始缩放比例，通过注入 JS 调整初始缩放比例&lt;/p&gt;

&lt;p&gt;加载页面之前，注入一段 JS 代码：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;language-objective-c&quot;&gt;CGFloat w = [[UIScreen mainScreen] bounds].size.width;
CGFloat ratio = w/750.0;

NSString *jScript = @&quot;var meta = document.createElement(&apos;meta&apos;); meta.setAttribute(&apos;name&apos;, &apos;viewport&apos;); meta.setAttribute(&apos;content&apos;, &apos;width=device-width,initial-scale=ratio,minimum-scale=0.30, maximum-scale=3.0, user-scalable=0&apos;); meta.setAttribute(&apos;content&apos;, &apos;width=device-width&apos;); document.getElementsByTagName(&apos;head&apos;)[0].appendChild(meta);&quot;;

jScript = [jScript stringByReplacingOccurrencesOfString:@&quot;ratio&quot; withString:[NSString stringWithFormat:@&quot;%f&quot;,ratio]];

WKUserScript *wkUScript = [[WKUserScript alloc] initWithSource:jScript injectionTime:WKUserScriptInjectionTimeAtDocumentEnd forMainFrameOnly:YES];
WKUserContentController *wkUController = [[WKUserContentController alloc] init];
[wkUController addUserScript:wkUScript];

WKWebViewConfiguration *wkWebConfig = [[WKWebViewConfiguration alloc] init];
wkWebConfig.userContentController = wkUController;

wkWebV = [[WKWebView alloc] initWithFrame:self.view.frame configuration:wkWebConfig];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样，webview 跟据当前 屏幕大小，自适应缩放 H5页面的大小。&lt;/p&gt;

&lt;p&gt;设置比例过小的效果图 ⤋
&lt;br /&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_2.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;设置缩放比例正确的效果 ⤋&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/iOS-webview-auto-scale/image_1.png&quot; width=&quot;200&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://stackoverflow.com/questions/26295277/wkwebview-equivalent-for-uiwebviews-scalespagetofit&quot;&gt;参考链接&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 17 Dec 2019 23:00:00 +0800</pubDate>
        <link>http://www.junziboxue.com/2019/12/17/scales-pagesize-to-fit/</link>
        <guid isPermaLink="true">http://www.junziboxue.com/2019/12/17/scales-pagesize-to-fit/</guid>
        
        <category>iOS</category>
        
        
      </item>
    
      <item>
        <title>关于自动驾驶伦理问题的思考</title>
        <description>&lt;p&gt;  在这里主要讨论自动驾驶技术的实际应用中，可能遇到的社会伦理问题以及相关思考。&lt;/p&gt;

&lt;p&gt;  目前市场上已经出现了可以自动驾驶的汽车，比如特斯拉、百度的阿波龙。 其中自动驾驶应用较为激进的当属特斯拉无疑。近几年 (2016-2018) 特斯拉的几起事故，可能与自动驾驶技术尚未完全成熟有关。而百度已获得全国首批T4道路测试牌照，自动驾达到L4级别的&lt;a href=&quot;http://apollo.auto/minibus/index_cn.html&quot;&gt;阿波龙&lt;/a&gt;已经于2018年7月4日正式量产下线，已经在多地开始展开试用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/apollo.jpg&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;（图为阿波龙自动驾驶汽车）&lt;/p&gt;

&lt;p&gt;  随着人工智能 AI (&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;Artificial Intelligence&lt;/code&gt;) 的事件处理能力和数据分析精度变得更强更高，自动驾驶技术也开始进入了实用阶段。当然，实现自动驾驶除了 AI 必不可少以外，还需要&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;计算机视觉&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;高精度地图&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;5G高速通信技术&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;激光雷达&lt;/code&gt;等环境感知技术。可以预见到不久的将来，自动驾驶功能将会成为汽车的标配功能，&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AI&lt;/code&gt; 也继 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;水&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;电&lt;/code&gt;、&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;网络&lt;/code&gt;之后，势必成为生活中必不可少的基础元素，潜入到生活的方方面面。&lt;/p&gt;

&lt;p&gt;  然而 AI 作为自动驾驶的主要决策单元，代替驾驶员做出决策，控制车辆在道路上行走，这将带来一系列的社会伦理问题和法律问题。在这里列出一些自动驾驶在不久的将来可能会遇到的问题，与大家一起讨论、思考。&lt;/p&gt;

&lt;h4 id=&quot;问题1&quot;&gt;问题1&lt;/h4&gt;

&lt;p&gt;自动驾驶汽车行驶过程中，遇突发事故，选择避让可能危及行人生命安全，不避让可能会导致乘客伤亡，AI 该如何决策？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/user-innocent-accident.png&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;这里有三个问题需要回答：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;strong&gt;&lt;em&gt;用户&lt;/em&gt;&lt;/strong&gt;和&lt;strong&gt;&lt;em&gt;行人&lt;/em&gt;&lt;/strong&gt;都是无辜者，AI 有了干预的机会后，突来的意外应该降临到谁身上？&lt;/li&gt;
  &lt;li&gt;自动驾驶汽车作为一款产品，AI 是优先保护用户的安全？还是优先保护行人的安全？&lt;/li&gt;
  &lt;li&gt;遇到以上场景，自动驾驶是否需要&lt;strong&gt;&lt;em&gt;乘客&lt;/em&gt;&lt;/strong&gt;做出决策？或者说乘客的决定和AI的决定哪个有效？（自动驾驶里弱化了 司机 的角色，司机更多是 可以干预驾驶的乘客）&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;问题2&quot;&gt;问题2&lt;/h4&gt;

&lt;p&gt;一辆火车失控，即将撞向铁路上的五个人，这时 AI 可以控制扳手让火车转向，撞向另外一条轨道上的一个人。是将伤亡将到最小，还是让事故继续发生？&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/autopilot/which-one-to-choose.png&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;人性、道德、法律，到底是谁做出了最终抉择？&lt;/p&gt;

&lt;p&gt;  这其实是美国哈佛大学政治哲学教授迈克尔·桑德尔，在公开课中设想的场景，用以描述行为选择的道德困境。在这里只是把人改为了 AI。在这里，不管 AI 如何处理，其最终决的选择实际来自于人，或者来自于人已经定制好的算法，AI 通过算法计算，忠实地执行了这个决定。&lt;/p&gt;

&lt;p&gt;  人可以为自己的决策和行为负责，那么AI的决策和行为谁来负责呢？&lt;/p&gt;

&lt;p&gt;  我认为这应该是社会群体层的共识问题，社会群体中的每个个体需要事先知晓 并接受 AI 的决策策略，在事故发生后， 所有人必须为算法的执行结果负责，因为这个是整个社会群体已经认可的选择。&lt;/p&gt;

&lt;p&gt;  当然 在现实中很难发生这种特殊情况，特别案例还需要根据实际情况具体分析，这里只是纯为讨论而假设的场景。&lt;/p&gt;

&lt;p&gt;自动驾驶不光光是 技术上的问题，法律和相关规范 是自动驾驶可以正常运行的必要条件。&lt;/p&gt;

&lt;p&gt;期待自动驾驶早点普及使用，在那之前，希望相关法律和规范已经落地执行。&lt;/p&gt;

&lt;p&gt;还有，没事不要到马路上溜达。&lt;/p&gt;

&lt;h3 id=&quot;end&quot;&gt;end&lt;/h3&gt;

&lt;p&gt;  写文章很有难度啊，写不下去了先在这里吐个槽，提升写作能力太有必要了。清楚明白地表达观点，并且让读者轻易的捕捉到你要表达的意思 ，让文章读起来感觉顺畅，同时保持整体有结构和层次，这些都不是那么容易的兼顾的到。想要提升写作能力，一番磨练必不可少啊。&lt;/p&gt;

&lt;p&gt;有问题或想法可以联系我讨论，邮箱：&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;meowchunfat@hotmail.com&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;声明：本篇为个人原创，允许转载，转载请注明出处。&lt;/p&gt;
</description>
        <pubDate>Thu, 07 Nov 2019 16:00:00 +0800</pubDate>
        <link>http://www.junziboxue.com/2019/11/07/auto-pilot-ethics/</link>
        <guid isPermaLink="true">http://www.junziboxue.com/2019/11/07/auto-pilot-ethics/</guid>
        
        <category>something</category>
        
        
      </item>
    
  </channel>
</rss>
